{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<ul> <li> Basics Python Basics</li> <li> JavaScript for interactivity</li> <li> CSS for text running out of boxes</li> <li> Internet Explorer ... huh?</li> </ul>"},{"location":"Docmosis/Templates/templates/","title":"Templates","text":""},{"location":"Docmosis/Tornado/tornado/","title":"Tornado","text":""},{"location":"Python/pythoniccode/","title":"Pythonic Code","text":""},{"location":"Python/pythoniccode/#comments","title":"Comments:","text":"<ul> <li>Keep lines within 72\u201380 characters.</li> <li>Use complete sentences in camel-case.</li> <li>Ensure comments are updated when code changes.</li> </ul>"},{"location":"Python/pythoniccode/#block-comments","title":"Block Comments:","text":"<ul> <li>Used for explaining sections of code or functionality.</li> <li>Follow PEP8: Match indent level with the code, begin with # + space.</li> <li>Use blank comment lines (#) between paragraphs.</li> </ul> Example of block comment<pre><code># This function calculates the area of a rectangle.\n# It takes width and height as inputs and returns the computed area.\ndef calculate_area(width, height):\n    return width * height\n</code></pre>"},{"location":"Python/pythoniccode/#inline-comments","title":"Inline Comments:","text":"<ul> <li>Place them at the end of the line they refer to.</li> <li>Use at least two spaces between the code and the comment.</li> <li>Avoid over-explaining obvious logic.</li> </ul> Example of inline comment<pre><code>def is_even(number):\n    return number % 2 == 0  # Check if the number is divisible by 2\n</code></pre>"},{"location":"Python/pythoniccode/#docstrings","title":"Docstrings:","text":"<ul> <li>Used to explain classes, modules, functions, or methods.</li> <li>Wrapped in triple quotes (\"\"\" or ''').</li> <li>Docstrings provide explanation, not justification, and are crucial for documenting expected input types, parameters, and return types.</li> <li>Unlike comments, docstrings are essential in Python for dynamic typing and better code understanding.</li> </ul> Example of Docstrings<pre><code>def greet(name):\n    \"\"\"\n    Greets a person by name.\n\n    Args:\n        name (str): The name of the person to greet.\n\n    Returns:\n        str: A greeting message.\n    \"\"\"\n    return f\"Hello, {name}!\"\n</code></pre>"},{"location":"Python/pythoniccode/#type-annotations","title":"Type Annotations:","text":"<p>Annotations in Python, introduced with PEP 3107, allow adding type hints to function arguments, return values, and variables. </p> <p>They help clarify what types of data are expected, without enforcing them,  as Python remains dynamically typed.</p> <p>Key Points:</p> <ul> <li>Type hints suggest expected data types (e.g., float, int) to users, but Python does not enforce these types.</li> <li>Annotations can be accessed through a special attribute, annotations, which returns a  dictionary of the annotations used in the function.</li> <li> <p>Type Hinting helps in static analysis tools like MyPy, which check data type compatibility.</p> </li> <li> <p>The typing module in Python 3.5+ allows specifying more complex types, like lists of specific  data types (e.g., List[float]).</p> </li> <li> <p>Starting from Python 3.6, variables can also be annotated, not just function parameters.</p> </li> </ul> <pre><code>class Rectangle:\n    length: float   # Type annotation for a variable\n    width: float\n    area: float\n\n    def __init__(self, length: float, width: float):\n        self.length = length\n        self.width = width\n        self.area = 0\n\n    def compute_area(self) -&gt; float:   # Type annotation for return type\n        \"\"\"Compute area of the rectangle.\"\"\"\n        return self.length * self.width\n\n# Accessing annotations\nprint(Rectangle.__annotations__)\n# Output: {'length': &lt;class 'float'&gt;, 'width': &lt;class 'float'&gt;, 'area': &lt;class 'float'&gt;}\n</code></pre> <p>In this example, length and width are expected to be floats, and the return type of compute_area is  also a float.</p> <p>Annotations can be accessed using annotations, and they help document expected types in code.</p> <p>PEP 484 emphasizes that type hints are optional and Python will remain dynamically typed,  meaning no mandatory type enforcement will occur.</p>"},{"location":"Python/pythoniccode/#code-layout-in-python","title":"Code layout in Python","text":""},{"location":"Python/pythoniccode/#blank-lines-in-python","title":"Blank Lines in Python:","text":"<p>In Python, spaces and blank lines are important for readability and code aesthetics.  Proper use of vertical whitespace helps improve clarity and reduces frustration when reading code.</p> <p>Key Guidelines:</p> <ul> <li> <p>Classes and top-level functions: Use two blank lines around them to visually isolate and  separate their functionality. <pre><code>class ClassOne:\n    pass\n\nclass ClassTwo:\n    pass\n\ndef my_top_level_function():\n    return None\n</code></pre></p> </li> <li> <p>Methods in a class: Use a single blank line between methods to show they are interrelated yet distinct. <pre><code>class MyClass:\n    def first_method(self):\n        return None\n\n    def second_method(self):\n        return None\n</code></pre></p> </li> <li> <p>Steps within a function: Separate different sections with a blank line if they represent distinct  steps or operations. <pre><code> def variance_computation(list_of_numbers):\n        list_sum = sum(list_of_numbers)\n        average = list_sum / len(list_of_numbers)\n\n        sum_of_squares = sum(num**2 for num in list_of_numbers)\n        average_of_squares = sum_of_squares / len(list_of_numbers)\n\n        return average_of_squares - average**2\n</code></pre></p> </li> </ul> <p>Benefits:</p> <ul> <li> <p>Improved readability: Blank lines help break up the code logically, making it easier to understand.</p> </li> <li> <p>Cleaner code: It prevents clutter and unnecessary scrolling, allowing developers to focus  on important sections.</p> </li> </ul>"},{"location":"Python/pythoniccode/#maximum-line-length-and-line-breaking-in-python","title":"Maximum Line Length and Line Breaking in Python:","text":"<p>PEP 8 recommends limiting a line of code to 79 characters to enhance readability  and avoid line wrapping, especially when editing multiple files side by side.</p> <p>Handling Long Lines: Within parentheses, braces, or brackets: The interpreter assumes the code is in continuation. <pre><code>def sample_method(first_arg, second_arg, third_arg):\n    return first_arg\n</code></pre></p> <p>Using backslashes: Break long lines with a backslash () for continuation outside of these constructs. <pre><code>from secretPackage import library1, \\\n                          library2, \\\n                          library3\n</code></pre> Implied continuation: Alternatively, use implied continuation by enclosing items in parentheses, brackets, or braces. <pre><code>from secretPackage import (\n    library1,\n    library2,\n    library3\n)\n</code></pre> Breaking before operators: For better readability, break lines before binary operators. <pre><code># Preferred\ntotal = (value_one\n         + value_two\n         - value_three)\n</code></pre></p> <p>Avoid breaking after operators, as it makes code harder to read. <pre><code>    # Less readable\n    total = (value_one + \n             value_two - \n             value_three)\n</code></pre> Benefits: *    Clarity: Breaking before operators improves readability. *    Better organization: Helps in editing code and reduces errors, especially when dealing with complex expressions.</p>"},{"location":"Python/syntax/","title":"Basic Syntax","text":""},{"location":"Python/syntax/#variables","title":"Variables","text":""},{"location":"Python/syntax/#nameing","title":"Nameing","text":"<p>A good variable name describes the data it contains. three rules: 1. It can be only one word with no spaces. 2. It can use only letters, numbers, and the underscore (_) character. 3. It can\u2019t begin with a number.</p>"},{"location":"Python/syntax/#flow-control-statements","title":"Flow Control Statements","text":""},{"location":"Python/syntax/#if-statement-consists-of-the-following","title":"if statement consists of the following:","text":"<ul> <li>The if keyword</li> <li>A condition (that is, an expression that evaluates to True or False)</li> <li>A colon</li> <li>Starting on the next line, an indented block of code (called the if clause)</li> </ul> <p><pre><code>if name == 'Alice':\n    print('Hi, Alice.')\n</code></pre> <pre><code>graph LR\n\n    A[Start] --&gt; B{Is the name 'Alice'?}\n    B -- Yes --&gt; C[Print 'Hi, Alice.']\n    B -- No --&gt; D[Do nothing]\n    C --&gt; E[End]\n    D --&gt; E[End]</code></pre></p>"},{"location":"Python/syntax/#else-statements","title":"else Statements","text":"<p>The else clause is executed only when the if statement\u2019s condition is False.</p> <p>An else statement always consists of the following: - The else keyword - A colon - Starting on the next line, an indented block of code (called the else clause) <pre><code>if name == 'Alice':\nprint('Hi, Alice.')\nelse:\nprint('Hello, stranger.')\n</code></pre></p> <pre><code>flowchart LR\n    A[Start] --&gt; B{Is the name 'Alice'?}\n    B -- True --&gt; C[Print 'Hi, Alice.']\n    B -- False --&gt; D[Print 'Hello, stranger.']\n    C --&gt; E[End]\n    D --&gt; E[End]\n</code></pre>"},{"location":"Python/syntax/#elif-statements","title":"elif Statements","text":"<p>The elif statement is an \u201celse if\u201d statement that always follows an if or another elif statement. It provides another condition that is checked only if all of the previous conditions were False .</p> <p>In code, an elif statement always consists of the following: - The elif keyword - A condition (that is, an expression that evaluates to True or False) - A colon Starting on the next line, an indented block of code (called the elif clause) <pre><code>if name == 'Alice':\nprint('Hi, Alice.')\nelif age &lt; 12:\nprint('You are not Alice, kiddo.')\n</code></pre> <pre><code>flowchart LR\n   A[Start] --&gt; B{Is the name 'Alice'?}\n    B -- Yes --&gt; C[Print 'Hi, Alice.']\n    B -- No --&gt; D{Is age &lt; 12?}\n    D -- Yes --&gt; E[Print 'You are not Alice, kiddo.']\n    D -- No --&gt; F[End]\n    C --&gt; F\n    E --&gt; F</code></pre> First, there is always exactly one if statement. Any elif statements you need should follow the if statement. Second, if you want to be sure that at least one clause is executed, close the structure with an else statement.</p>"},{"location":"Python/syntax/#while-loop-statements","title":"while Loop Statements","text":"<p>The code in a while clause will be executed as long as the while statement\u2019s condition is True. </p> <p>In code, a while statement always consists of the following: - The while keyword - A condition (that is, an expression that evaluates to True or False) - A colon - Starting on the next line, an indented block of code (called the while clause)</p> <p>In the while loop, the condition is always checked at the start of each iteration (that is, each time the loop is executed). If the condition is True, then the clause is executed, and afterward, the condition is checked again. The \ufb01rst time the condition is found to be False, the while clause is skipped.</p> <p>break Statements There is a shortcut to getting the program execution to break out of a while loop\u2019s clause early. If the execution reaches a break statement, it immediately exits the while loop\u2019s clause. In code, a break statement simply contains the break keyword.</p> <p>continue Statements Like break statements, continue statements are used inside loops. When the program execution reaches a continue statement, the program execution immediately jumps back to the start of the loop and reevaluates the loop\u2019s condition. </p>"},{"location":"Python/syntax/#for-loops-and-the-range-function","title":"for Loops and the range() Function","text":"<p>In code, a for statement looks something like for i in range(5): and includes the following: - The for keyword - A variable name - The in keyword - A call to the range() method with up to three integers passed to it - A colon - Starting on the next line, an indented block of code (called the for clause)</p> <p><pre><code>print('My name is')\nfor i in range(5):\n    print('Jimmy Five Times (' + str(i) + ')')\n\n#output\nimmy Five Times (0)\nJimmy Five Times (1)\nJimmy Five Times (2)\nJimmy Five Times (3)\nJimmy Five Times (4)\n</code></pre> The range() function can also be called with three arguments. The \ufb01rst argument will be where the for loop\u2019s variable starts, and the second argument will be up to, but not including, the number to stop at and the third will be the step argument. The step is the amount that the variable is increased by after each iteration.</p> <pre><code>for i in range(0, 10, 2):  #ie (start,end,step)\nprint(i)\n#So calling range(0, 10, 2) will count from zero to eight by intervals of two.\n#result    \n0\n2\n4\n6\n8\n</code></pre>"},{"location":"Python/syntax/#example","title":"Example","text":"<pre><code>import random\nimport sys\n\nprint('ROCK, PAPER, SCISSORS')\n\n# These variables keep track of the number of wins, losses, and ties.\nwins = 0\nlosses = 0\nties = 0\n\nwhile True:  # The main game loop.\n    print(f'{wins} Wins, {losses} Losses, {ties} Ties')\n\n    while True:  # The player input loop.\n        print('Enter your move: (r)ock (p)aper (s)cissors or (q)uit')\n        playerMove = input()\n\n        if playerMove == 'q':\n            sys.exit()  # Quit the program.\n\n        if playerMove in ['r', 'p', 's']:\n            break  # Break out of the player input loop.\n\n        print('Type one of r, p, s, or q.')\n\n    # Display what the player chose:\n    if playerMove == 'r':\n        print('ROCK versus...')\n    elif playerMove == 'p':\n        print('PAPER versus...')\n    elif playerMove == 's':\n        print('SCISSORS versus...')\n\n    # Display what the computer chose:\n    randomNumber = random.randint(1, 3)\n\n    if randomNumber == 1:\n        computerMove = 'r'\n        print('ROCK')\n    elif randomNumber == 2:\n        computerMove = 'p'\n        print('PAPER')\n    elif randomNumber == 3:\n        computerMove = 's'\n        print('SCISSORS')\n\n    # Display and record the win/loss/tie:\n    if playerMove == computerMove:\n        print('It is a tie!')\n        ties += 1\n    elif (playerMove == 'r' and computerMove == 's') or \\\n            (playerMove == 'p' and computerMove == 'r') or \\\n            (playerMove == 's' and computerMove == 'p'):\n        print('You win!')\n        wins += 1\n    else:\n        print('You lose!')\n        losses += 1\n</code></pre>"},{"location":"Python/Flask/Flask-deployment/","title":"Flask deployment","text":"<p>Flask- Live deployment (GPT-undeited)</p>"},{"location":"Python/Flask/Flask-deployment/#1-use-a-wsgi-server-eg-gunicorn-or-uwsgi","title":"1. Use a WSGI Server (e.g., Gunicorn or uWSGI)","text":"<p>Flask, in production, should be served using a WSGI server like Gunicorn or uWSGI, not the built-in Flask server. This server will handle the requests and responses efficiently, allowing you to serve multiple clients and handle more traffic.</p>"},{"location":"Python/Flask/Flask-deployment/#install-gunicorn","title":"Install Gunicorn:","text":"<pre><code>(venv) $ pip install gunicorn\n</code></pre> <p>You can then run your app using Gunicorn: <pre><code>(venv) $ gunicorn -w 4 -b 127.0.0.1:8000 microblog:app\n</code></pre> Here: - <code>-w 4</code> tells Gunicorn to run 4 worker processes. - <code>-b 127.0.0.1:8000</code> binds the server to the specified IP and port. - <code>microblog:app</code> specifies the entry point for the WSGI app (the <code>app</code> object from <code>microblog.py</code>).</p>"},{"location":"Python/Flask/Flask-deployment/#2-configure-nginx","title":"2. Configure Nginx","text":"<p>Nginx will serve as a reverse proxy, forwarding requests from the outside world to your Flask app running on Gunicorn. It will also handle static files efficiently.</p>"},{"location":"Python/Flask/Flask-deployment/#nginx-configuration","title":"Nginx Configuration:","text":"<ol> <li> <p>Install Nginx on your server:    <pre><code>$ sudo apt install nginx\n</code></pre></p> </li> <li> <p>Create an Nginx server block configuration file for your app:    Create a file in <code>/etc/nginx/sites-available/</code>:    <pre><code>$ sudo nano /etc/nginx/sites-available/microblog\n</code></pre></p> </li> </ol> <p>Add the following configuration:    <pre><code>server {\n    listen 80;\n    server_name your_domain_or_IP;\n\n    location / {\n        proxy_pass http://127.0.0.1:8000;\n        proxy_set_header Host $host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n\n    location /static {\n        alias /path/to/microblog/app/static;\n    }\n}\n</code></pre></p> <p>Replace <code>your_domain_or_IP</code> with your server\u2019s IP address or domain name. Also, update the path for <code>/static</code> to point to where your static files are located in your Flask app.</p> <ol> <li> <p>Enable the site by creating a symlink in the <code>sites-enabled</code> directory:    <pre><code>$ sudo ln -s /etc/nginx/sites-available/microblog /etc/nginx/sites-enabled\n</code></pre></p> </li> <li> <p>Restart Nginx to apply the changes:    <pre><code>$ sudo systemctl restart nginx\n</code></pre></p> </li> </ol>"},{"location":"Python/Flask/Flask-deployment/#3-use-environment-variables","title":"3. Use Environment Variables","text":"<p>In production, you\u2019ll likely need to switch from the <code>.env</code> file to actual system environment variables for security. Instead of using <code>python-dotenv</code>, you can set environment variables directly on the server.</p>"},{"location":"Python/Flask/Flask-deployment/#set-environment-variables-example-for-linux","title":"Set environment variables (example for Linux):","text":"<pre><code>$ export FLASK_APP=microblog.py\n$ export FLASK_ENV=production\n</code></pre> <p>Alternatively, add them to <code>/etc/environment</code> or create a systemd service file for running the application, which would automatically set the environment variables when starting the app.</p>"},{"location":"Python/Flask/Flask-deployment/#4-configure-gunicorn-as-a-service","title":"4. Configure Gunicorn as a Service","text":"<p>To ensure your app starts on boot and is always running, you can set Gunicorn to run as a service using systemd.</p> <ol> <li>Create a systemd service file:    <pre><code>$ sudo nano /etc/systemd/system/microblog.service\n</code></pre></li> </ol> <p>Add the following:    <pre><code>[Unit]\nDescription=Gunicorn instance to serve microblog\nAfter=network.target\n\n[Service]\nUser=your_user\nGroup=www-data\nWorkingDirectory=/path/to/microblog\nEnvironment=\"PATH=/path/to/microblog/venv/bin\"\nExecStart=/path/to/microblog/venv/bin/gunicorn --workers 4 --bind 127.0.0.1:8000 microblog:app\n\n[Install]\nWantedBy=multi-user.target\n</code></pre></p> <ol> <li>Start and enable the service:    <pre><code>$ sudo systemctl start microblog\n$ sudo systemctl enable microblog\n</code></pre></li> </ol>"},{"location":"Python/Flask/Flask-deployment/#5-security-considerations","title":"5. Security Considerations","text":"<ul> <li>Make sure your Flask app runs in <code>production</code> mode (<code>FLASK_ENV=production</code>).</li> <li>Set up a firewall to only allow HTTP/HTTPS traffic.</li> <li>Use HTTPS with Nginx by setting up SSL certificates (e.g., via Let\u2019s Encrypt).</li> </ul>"},{"location":"Python/Flask/Flask-deployment/#summary-of-steps","title":"Summary of Steps:","text":"<ol> <li>Install Gunicorn or uWSGI to serve your Flask app.</li> <li>Configure Nginx as a reverse proxy to forward requests to your WSGI server.</li> <li>Set up environment variables properly.</li> <li>Optionally configure systemd to ensure the app runs on boot.</li> </ol> <p>This setup allows your Flask app to handle real-world traffic efficiently and securely on a Linux server with Nginx.</p>"},{"location":"Python/Flask/classbasedviews/","title":"Class-based Views in Flask","text":"<p>A class-based view is a class that acts like a view function in Flask. </p> <p>The benefit of using a class is that it allows for reusable, modular, and extensible views. </p> <p>Flask provides two main classes for creating these views: View and MethodView. </p> <p>These classes help us handle logic in a structured way, especially when dealing with multiple models  or complex API behavior.</p>"},{"location":"Python/Flask/classbasedviews/#example-converting-a-function-based-view-to-a-class-based-view","title":"Example: Converting a Function-based View to a Class-based View","text":"<p>Let\u2019s start by looking at a common function-based view, which queries a list of users and renders a template to display them:</p> <pre><code>@app.route(\"/users/\")\ndef user_list():\n    users = User.query.all()\n    return render_template(\"users.html\", users=users)\n</code></pre> <p>If you need similar views for different models (like a list of products or posts), you'd have to write new functions for each one. But with a class-based view, we can make this reusable.</p>"},{"location":"Python/Flask/classbasedviews/#using-the-view-class","title":"Using the <code>View</code> Class","text":"<p>Let\u2019s create a class-based view that does the same thing but allows for more flexibility:</p> <pre><code>from flask.views import View\n\nclass UserList(View):\n    def dispatch_request(self):\n        users = User.query.all()\n        return render_template(\"users.html\", users=users)\n</code></pre> <ul> <li>The <code>dispatch_request()</code> method replaces the view function. It handles requests and returns a response.</li> <li>To register the view with Flask, you use <code>add_url_rule()</code>:</li> </ul> <pre><code>app.add_url_rule(\"/users/\", view_func=UserList.as_view(\"user_list\"))\n</code></pre> <p>This makes the <code>UserList</code> class handle requests to <code>/users/</code>. </p> <p>The method <code>as_view()</code> creates a view function from the class, which Flask uses to route requests.</p> <p>In the example provided, the <code>\"user_list\"</code> in <code>UserList.as_view(\"user_list\")</code> is simply a name or identifier for that specific view. </p> <p>It is a label that Flask uses internally to refer to the view when generating URLs or debugging.</p> <p>Here\u2019s a breakdown:</p> <ul> <li><code>UserList</code> is the class-based view we created.</li> <li> <p><code>UserList.as_view(\"user_list\")</code> converts the class into a view function. </p> </li> <li> <p>The <code>\"user_list\"</code> here is the name given to that view function. </p> </li> <li> <p>This name can be used later to generate URLs for the view with <code>url_for()</code>. </p> </li> </ul> <p>For example, if you wanted to link to this view in a template, you could do something like this:</p> <pre><code>&lt;a href=\"{{ url_for('user_list') }}\"&gt;Users&lt;/a&gt;\n</code></pre> <p>The <code>url_for('user_list')</code> will generate the URL <code>/users/</code> because that\u2019s where we  mapped the view with <code>add_url_rule()</code></p> <p>So, the <code>\"user_list\"</code> part does not come from the class itself but is a name you provide when  creating the view function via <code>as_view()</code>. </p> <p>It\u2019s just a string identifier for that specific view, used by Flask to reference the view.</p>"},{"location":"Python/Flask/classbasedviews/#making-the-view-reusable-for-different-models","title":"Making the View Reusable for Different Models","text":"<p>Now, let\u2019s make the view more flexible so that it can handle different models (like products, stories, etc.) and templates. We will pass the model and template as arguments to the class:</p> <pre><code>class ListView(View):\n    def __init__(self, model, template):\n        self.model = model\n        self.template = template\n\n    def dispatch_request(self):\n        items = self.model.query.all()\n        return render_template(self.template, items=items)\n</code></pre> <p>You can now use this class to handle lists for any model. For example, for users and stories:</p> <pre><code>app.add_url_rule(\n    \"/users/\", \n    view_func=ListView.as_view(\"user_list\", User, \"users.html\")\n)\napp.add_url_rule(\n    \"/stories/\", \n    view_func=ListView.as_view(\"story_list\", Story, \"stories.html\")\n)\n</code></pre> <p>This avoids duplicating view logic for each model. You simply reuse the same class and pass the necessary model and template when registering the view.</p>"},{"location":"Python/Flask/classbasedviews/#different-querys-for-different-models","title":"Different querys for different models","text":"<p>It is absolutely possible to handle different queries for different models by extending  the <code>ListView</code> class or by providing a custom query function for each model. </p> <p>You can modify the <code>dispatch_request</code> method or pass in additional logic when you register the view.</p> <p>Here are two approaches:</p>"},{"location":"Python/Flask/classbasedviews/#approach-1-passing-custom-query-logic","title":"Approach 1: Passing Custom Query Logic","text":"<p>You can extend the <code>ListView</code> to accept a query function when registering the view, allowing you to specify different queries for different models.</p> <p>Here's how you can modify the class to accept a custom query:</p> <pre><code>class ListView(View):\n    def __init__(self, model, template, query_func=None):\n        self.model = model\n        self.template = template\n        self.query_func = query_func  # Optional query function\n\n    def dispatch_request(self):\n        # If a custom query function is provided, use it. Otherwise, query all.\n        if self.query_func:\n            items = self.query_func(self.model)\n        else:\n            items = self.model.query.all()\n        return render_template(self.template, items=items)\n</code></pre> <p>Now, when registering the view, you can provide a custom query function for different models:</p> <pre><code># Custom query function for stories\ndef get_recent_stories(model):\n    return model.query.filter(model.published_date &gt; '2023-01-01').all()\n\napp.add_url_rule(\n    \"/users/\",\n    view_func=ListView.as_view(\"user_list\", User, \"users.html\")\n)\n\napp.add_url_rule(\n    \"/stories/\",\n    view_func=ListView.as_view(\"story_list\", Story, \"stories.html\", query_func=get_recent_stories)\n)\n</code></pre> <p>In this case, the <code>get_recent_stories</code> function filters stories published after January 1st, 2023, while for users, it still retrieves all records.</p>"},{"location":"Python/Flask/classbasedviews/#approach-2-subclassing-for-specific-queries","title":"Approach 2: Subclassing for Specific Queries","text":"<p>Another way is to subclass <code>ListView</code> for each model, where you can customize the query in each subclass.</p> <pre><code>class UserListView(ListView):\n    def dispatch_request(self):\n        # Custom query for users\n        items = self.model.query.all()\n        return render_template(self.template, items=items)\n\nclass StoryListView(ListView):\n    def dispatch_request(self):\n        # Custom query for stories (e.g., filter by published date)\n        items = self.model.query.filter(self.model.published_date &gt; '2023-01-01').all()\n        return render_template(self.template, items=items)\n</code></pre> <p>And then you can register them:</p> <pre><code>app.add_url_rule(\n    \"/users/\",\n    view_func=UserListView.as_view(\"user_list\", User, \"users.html\")\n)\n\napp.add_url_rule(\n    \"/stories/\",\n    view_func=StoryListView.as_view(\"story_list\", Story, \"stories.html\")\n)\n</code></pre>"},{"location":"Python/Flask/classbasedviews/#summary","title":"Summary","text":"<ul> <li> <p>First approach: You pass a custom query function during view registration to handle different queries for different models.</p> </li> <li> <p>Second approach: You subclass the <code>ListView</code> and customize the query logic within the <code>dispatch_request</code> method for each model.</p> </li> </ul> <p>Both approaches allow for flexibility, and the choice depends on how much you want  to reuse the base class. The first approach keeps everything within one class, while the second is more object-oriented and keeps model-specific logic in subclasses.</p>"},{"location":"Python/Flask/classbasedviews/#handling-url-variables-in-class-based-views","title":"Handling URL Variables in Class-based Views","text":"<p>If your view needs to handle URL variables (like <code>/users/&lt;id&gt;</code>), you can modify <code>dispatch_request()</code> to accept parameters, just as you would with a function-based view.</p> <p>Let\u2019s create a detail view that retrieves a specific user by their ID:</p> <pre><code>class DetailView(View):\n    def __init__(self, model):\n        self.model = model\n        self.template = f\"{model.__name__.lower()}/detail.html\"\n\n    def dispatch_request(self, id):\n        item = self.model.query.get_or_404(id)\n        return render_template(self.template, item=item)\n</code></pre> <p>In this example, we dynamically set the template path based on the model\u2019s name. Now, register the view for user details:</p> <pre><code>app.add_url_rule(\n    \"/users/&lt;int:id&gt;\",\n    view_func=DetailView.as_view(\"user_detail\", User)\n)\n</code></pre> <p>When a request is made to <code>/users/1</code>, Flask will call the <code>dispatch_request()</code> method with <code>id=1</code>, fetch the user with that ID, and render the detail page.</p>"},{"location":"Python/Flask/classbasedviews/#optimizing-view-instantiation-with-init_every_request","title":"Optimizing View Instantiation with <code>init_every_request</code>","text":"<p>By default, Flask creates a new instance of the view class for every request. This means you can safely store request-specific data on <code>self</code> without worrying about conflicts between requests. However, if the class does a lot of initialization work, this can be inefficient.</p> <p>To avoid creating a new instance for every request, you can set the <code>init_every_request</code> attribute to <code>False</code>:</p> <pre><code>class ListView(View):\n    init_every_request = False\n\n    def __init__(self, model, template):\n        self.model = model\n        self.template = template\n\n    def dispatch_request(self):\n        items = self.model.query.all()\n        return render_template(self.template, items=items)\n</code></pre> <p>Now, the view instance will be created only once and reused for all requests. </p> <p>However, this means you should not store request-specific data in <code>self</code>. </p> <p>Instead, use Flask\u2019s <code>g</code> object for request-scoped data.</p>"},{"location":"Python/Flask/classbasedviews/#example-using-flasks-g-for-request-scoped-data","title":"Example: Using Flask's <code>g</code> for Request-Scoped Data","text":"<p>Flask\u2019s <code>g</code> object is a globally available object in Flask that is used to store data  for the lifetime of a request. </p> <p>Since <code>g</code> is request-scoped, it resets for every new request,  making it ideal for storing request-specific data when you want to avoid  storing that data in the class itself.</p> <p>Let\u2019s modify the <code>ListView</code> class so that instead of storing request-specific data (like user information or any data that changes per request) in <code>self</code>, it stores it in the <code>g</code> object.</p> <p>For instance, let's imagine we want to store the currently logged-in user's information and  use that data across multiple requests.</p> <p>Here\u2019s an example where <code>g.user</code> is used to hold user data for each request:</p> <pre><code>from flask import g, request\nfrom flask.views import View\n\nclass ListView(View):\n    init_every_request = False\n\n    def __init__(self, model, template):\n        self.model = model\n        self.template = template\n\n    def before_request(self):\n        # Example: Simulate getting user info from a request (like from a session or a token)\n        g.user = request.args.get('user', 'Guest')\n\n    def dispatch_request(self):\n        # Call before_request method to store user data in g\n        self.before_request()\n\n        # Query model data (e.g., all items or user-specific data)\n        items = self.model.query.all()\n\n        # Pass both the items and the request-specific user info to the template\n        return render_template(self.template, items=items, user=g.user)\n</code></pre>"},{"location":"Python/Flask/classbasedviews/#whats-happening-here","title":"What\u2019s happening here:","text":"<ol> <li><code>g.user</code>: We're simulating storing user data in <code>g</code> (in a real-world scenario, this might come from session data or a token).</li> <li><code>self.before_request()</code>: We call <code>before_request()</code> inside <code>dispatch_request()</code> to store request-specific information (like <code>g.user</code>).</li> <li>Template Rendering: We pass the <code>g.user</code> data to the template along with the queried <code>items</code>.</li> </ol>"},{"location":"Python/Flask/classbasedviews/#registering-the-view","title":"Registering the View","text":"<pre><code>app.add_url_rule(\n    \"/items/\",\n    view_func=ListView.as_view(\"item_list\", ItemModel, \"items.html\")\n)\n</code></pre>"},{"location":"Python/Flask/classbasedviews/#explanation","title":"Explanation:","text":"<ul> <li><code>g</code> is request-scoped: <code>g</code> resets for each request, so storing user information or any request-specific data in it makes sure it\u2019s not shared across requests, unlike if you were to store it in <code>self</code>.</li> <li>Efficiency: Since the view instance is reused (because <code>init_every_request = False</code>), using <code>g</code> prevents issues where request-specific data might bleed between requests.</li> </ul>"},{"location":"Python/Flask/classbasedviews/#template-example-itemshtml","title":"Template Example (<code>items.html</code>)","text":"<p>Here\u2019s how the template might look, where it shows the items along with the currently logged-in user:</p> <pre><code>&lt;html&gt;\n&lt;body&gt;\n    &lt;h1&gt;Welcome, {{ user }}!&lt;/h1&gt;\n    &lt;ul&gt;\n    {% for item in items %}\n        &lt;li&gt;{{ item.name }}&lt;/li&gt;\n    {% endfor %}\n    &lt;/ul&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"Python/Flask/classbasedviews/#summary_1","title":"Summary:","text":"<ul> <li>Reuse View Instances: By setting <code>init_every_request = False</code>, we ensure the view instance is not created for each request.</li> <li><code>g</code> Object: Use Flask's <code>g</code> to store request-specific data like user information, which you can safely access throughout the request's lifecycle.</li> <li>Separation of Concerns: This approach cleanly separates request-specific data from the class instance, improving clarity and preventing potential issues with reused instances.</li> </ul>"},{"location":"Python/Flask/classbasedviews/#using-decorators-with-class-based-views","title":"Using Decorators with Class-based Views","text":"<p>Just like function-based views, you may want to apply decorators like <code>@login_required</code> or caching to class-based views. You can't apply decorators directly to the class, but you can set the <code>decorators</code> attribute.</p> <p>Here\u2019s an example where we apply both a cache decorator and <code>login_required</code> to a user list view:</p> <pre><code>class UserList(View):\n    decorators = [cache(minutes=2), login_required]\n\n    def dispatch_request(self):\n        users = User.query.all()\n        return render_template(\"users.html\", users=users)\n</code></pre> <p>When registering the view, Flask will automatically apply the decorators in the order you specified:</p> <pre><code>app.add_url_rule('/users/', view_func=UserList.as_view('user_list'))\n</code></pre> <p>Alternatively, you can manually apply decorators when creating the view function:</p> <pre><code>view = UserList.as_view(\"user_list\")\nview = cache(minutes=2)(view)\nview = login_required(view)\napp.add_url_rule('/users/', view_func=view)\n</code></pre>"},{"location":"Python/Flask/classbasedviews/#using-methodview-for-multiple-http-methods","title":"Using <code>MethodView</code> for Multiple HTTP Methods","text":"<p>Flask\u2019s <code>MethodView</code> class makes it easier to handle multiple HTTP methods like GET, POST, DELETE within a single view class.</p> <p>Here\u2019s an example of a registration form that supports both GET (to show the form) and POST (to process form data):</p> <pre><code>from flask.views import MethodView\nfrom flask import request, render_template\n\nclass RegisterView(MethodView):\n    def get(self):\n        return render_template(\"register.html\")\n\n    def post(self):\n        name = request.form['name']\n        # Process the form data\n        return f\"Registered {name} successfully!\"\n</code></pre> <p>Now register the view and specify that it handles both GET and POST methods:</p> <pre><code>app.add_url_rule('/register/', view_func=RegisterView.as_view('register_view'))\n</code></pre> <p>By using <code>MethodView</code>, you don\u2019t need to check <code>request.method == \"POST\"</code> manually. Flask will automatically route the request to the correct method based on the HTTP verb used.</p>"},{"location":"Python/Flask/classbasedviews/#summary_2","title":"Summary","text":"<ul> <li>View Class: Provides a simple way to turn functions into reusable classes, allowing you to handle common logic for different models and templates.</li> <li>MethodView Class: Offers an easy way to manage multiple HTTP methods (GET, POST, DELETE, etc.) within the same view class.</li> <li>Decorators: Can be applied to class-based views using the <code>decorators</code> attribute or by manually wrapping the view function.</li> <li>Efficient Instantiation: Use <code>init_every_request = False</code> to create a single instance of the class, avoiding unnecessary initialization on every request.</li> </ul> <p>Class-based views are especially useful when dealing with complex logic, reusable views, or applications that need to scale, providing structure and clarity to your code.</p>"},{"location":"Python/Flask/classbasedviews/#why-use-class-based-views","title":"Why Use Class-based Views?","text":"<ul> <li> <p>Better Organization: Class-based views allow you to encapsulate related view logic into classes, especially if you're dealing with multiple HTTP methods. This is more organized than handling everything in separate functions.</p> </li> <li> <p>Reusability: You can create base view classes and subclass them for related views. This makes your code more maintainable.</p> </li> <li> <p>MethodView for Multiple HTTP Methods: The <code>MethodView</code> class makes it easy to handle different HTTP methods in a clean, organized way.</p> </li> </ul>"},{"location":"Python/Flask/classbasedviews/#comparing-function-based-and-class-based-views","title":"Comparing Function-based and Class-based Views:","text":"Decorated Function View Class-based View (<code>View</code>/<code>MethodView</code>) Simpler and great for small views Better for organizing complex views Uses <code>@app.route()</code> for routing Uses <code>add_url_rule()</code> for routing Good for single HTTP methods Perfect for handling multiple HTTP methods Less structured for large apps Provides structure and reusability for larger apps <p>In conclusion, class-based views in Flask offer a flexible and scalable way to manage complex view logic, especially when working with multiple HTTP methods or large applications. Using classes allows you to encapsulate related logic and better organize your code compared to function-based views.</p>"},{"location":"Python/Flask/classbasedviews/#method-dispatching-with-methodview","title":"Method Dispatching with <code>MethodView</code>","text":"<p>This explanation covers method dispatching in Flask using <code>MethodView</code>, a class-based view that automatically maps HTTP methods to corresponding methods in a class, making it particularly useful for building RESTful APIs.</p> <p><code>MethodView</code> extends Flask's basic <code>View</code> class to handle different HTTP methods by mapping them to methods with the same name (in lowercase) within the class. This allows you to structure API endpoints in a more organized and readable way.</p> <p>Here\u2019s a breakdown of how it works:</p> <ol> <li>Automatic Method Mapping:    Each HTTP method (like <code>GET</code>, <code>POST</code>, <code>PATCH</code>, or <code>DELETE</code>) maps directly to a method in the class with the same lowercase name. For example:</li> <li>The HTTP <code>GET</code> method is handled by the <code>get()</code> method in the class.</li> <li>The HTTP <code>PATCH</code> method is handled by the <code>patch()</code> method.</li> <li> <p>The HTTP <code>DELETE</code> method is handled by the <code>delete()</code> method.</p> </li> <li> <p>Dynamic Dispatching:    When a request is made to an endpoint, <code>MethodView</code> automatically dispatches (routes) the request to the correct method of the class based on the HTTP method of the request (e.g., <code>GET</code>, <code>POST</code>, etc.).</p> </li> </ol>"},{"location":"Python/Flask/classbasedviews/#example-building-an-api","title":"Example: Building an API","text":"<p>Let\u2019s walk through the provided code examples to understand how <code>MethodView</code> simplifies RESTful API design.</p>"},{"location":"Python/Flask/classbasedviews/#itemapi-handles-single-items-detail-update-delete","title":"<code>ItemAPI</code>: Handles Single Items (Detail, Update, Delete)","text":"<p>This class manages detail views for individual items (such as a single user or story), supporting: - <code>GET</code> (retrieve item details), - <code>PATCH</code> (edit the item), - <code>DELETE</code> (remove the item).</p> <pre><code>class ItemAPI(MethodView):\n    init_every_request = False\n\n    def __init__(self, model):\n        self.model = model\n        self.validator = generate_validator(model)  # Initialize a validation system for the model\n\n    def _get_item(self, id):\n        return self.model.query.get_or_404(id)  # Get item by ID or raise a 404 error\n\n    def get(self, id):\n        item = self._get_item(id)  # Retrieve an item by ID\n        return jsonify(item.to_json())  # Return the item as JSON\n\n    def patch(self, id):\n        item = self._get_item(id)  # Retrieve item by ID\n        errors = self.validator.validate(item, request.json)  # Validate the data\n\n        if errors:\n            return jsonify(errors), 400  # Return errors if validation fails\n\n        item.update_from_json(request.json)  # Update the item with the new data\n        db.session.commit()  # Commit the changes to the database\n        return jsonify(item.to_json())  # Return the updated item\n\n    def delete(self, id):\n        item = self._get_item(id)  # Retrieve item by ID\n        db.session.delete(item)  # Delete the item from the database\n        db.session.commit()  # Commit the deletion\n        return \"\", 204  # Return a 204 (No Content) response\n</code></pre> <ul> <li><code>GET /users/&lt;id&gt;</code>: Retrieves a single user by ID.</li> <li><code>PATCH /users/&lt;id&gt;</code>: Updates a user with the provided JSON data.</li> <li><code>DELETE /users/&lt;id&gt;</code>: Deletes a user by ID.</li> </ul>"},{"location":"Python/Flask/classbasedviews/#groupapi-handles-collections-list-create","title":"<code>GroupAPI</code>: Handles Collections (List, Create)","text":"<p>This class manages collection views for multiple items (like a list of users or stories), supporting: - <code>GET</code> (list all items), - <code>POST</code> (create a new item).</p> <pre><code>class GroupAPI(MethodView):\n    init_every_request = False\n\n    def __init__(self, model):\n        self.model = model\n        self.validator = generate_validator(model, create=True)  # Validation for creating new items\n\n    def get(self):\n        items = self.model.query.all()  # Query all items\n        return jsonify([item.to_json() for item in items])  # Return all items as a JSON list\n\n    def post(self):\n        errors = self.validator.validate(request.json)  # Validate the incoming JSON data\n\n        if errors:\n            return jsonify(errors), 400  # Return errors if validation fails\n\n        item = self.model.from_json(request.json)  # Create a new item from the JSON data\n        db.session.add(item)  # Add the new item to the database\n        db.session.commit()  # Commit the changes\n        return jsonify(item.to_json())  # Return the newly created item\n</code></pre> <ul> <li><code>GET /users/</code>: Returns a list of all users.</li> <li><code>POST /users/</code>: Creates a new user with the provided JSON data.</li> </ul>"},{"location":"Python/Flask/classbasedviews/#registering-the-api","title":"Registering the API","text":"<p>The <code>register_api()</code> function binds both <code>ItemAPI</code> and <code>GroupAPI</code> classes to specific URLs for each model (e.g., users or stories). This function simplifies the registration of API routes.</p> <pre><code>def register_api(app, model, name):\n    item = ItemAPI.as_view(f\"{name}-item\", model)  # Create a view for handling individual items\n    group = GroupAPI.as_view(f\"{name}-group\", model)  # Create a view for handling collections\n    app.add_url_rule(f\"/{name}/&lt;int:id&gt;\", view_func=item)  # Register the item view for /&lt;name&gt;/&lt;id&gt;\n    app.add_url_rule(f\"/{name}/\", view_func=group)  # Register the group view for /&lt;name&gt;/\n</code></pre> <p>In this case: - <code>register_api(app, User, \"users\")</code> registers the routes for users:   - <code>/users/&lt;id&gt;</code> for detail, update, and delete.   - <code>/users/</code> for list and create.</p> <ul> <li><code>register_api(app, Story, \"stories\")</code> registers the routes for stories:</li> <li><code>/stories/&lt;id&gt;</code> for detail, update, and delete.</li> <li><code>/stories/</code> for list and create.</li> </ul>"},{"location":"Python/Flask/classbasedviews/#rest-api-routes","title":"REST API Routes","text":"<p>Here\u2019s a summary of the API endpoints produced by this approach:</p> URL Method Description <code>/users/</code> GET List all users <code>/users/</code> POST Create a new user <code>/users/&lt;id&gt;</code> GET Show a single user <code>/users/&lt;id&gt;</code> PATCH Update a user <code>/users/&lt;id&gt;</code> DELETE Delete a user <code>/stories/</code> GET List all stories <code>/stories/</code> POST Create a new story <code>/stories/&lt;id&gt;</code> GET Show a single story <code>/stories/&lt;id&gt;</code> PATCH Update a story <code>/stories/&lt;id&gt;</code> DELETE Delete a story"},{"location":"Python/Flask/classbasedviews/#advantages-of-methodview-for-apis","title":"Advantages of MethodView for APIs","text":"<ol> <li>Separation of HTTP Methods: Each HTTP method (<code>GET</code>, <code>POST</code>, <code>PATCH</code>, <code>DELETE</code>) is defined in its own method within the class, making the logic more organized and easier to understand.</li> <li>Reuse of Code: <code>MethodView</code> allows for efficient reuse of common logic, such as fetching models, handling errors, and validating data.</li> <li>Extensibility: Subclasses can easily extend or override methods to customize behavior for specific models or endpoints.</li> <li>Registration Flexibility: By using <code>register_api()</code>, you can quickly set up REST API routes for any model, making it highly reusable.</li> </ol> <p>In conclusion, using <code>MethodView</code> for method dispatching in Flask helps simplify the creation of RESTful APIs by neatly organizing different HTTP methods and making the codebase more maintainable.</p>"},{"location":"Python/Flask/dynamicroutes/","title":"Dynamic Routes in Flask","text":"<p>Flask allows for the creation of dynamic routes,  which enable URLs to change based on values passed into them,  called path variables. </p> <p>Path variables are placeholders in the URL that are identified  inside diamond operators <code>&lt;&gt;</code>, like <code>&lt;variable&gt;</code>. </p> <p>These allow a single route to handle multiple variations of a URL, depending on the values passed in.</p>"},{"location":"Python/Flask/dynamicroutes/#declaring-path-variables","title":"Declaring Path Variables","text":"<ul> <li>Path variables are inserted in the URL using the <code>&lt;type:variable&gt;</code> pattern.</li> <li>Types can be specified to enforce data types for the variables:</li> <li><code>string</code>: (default) Takes any valid characters except slashes.</li> <li><code>int</code>: Only accepts integers.</li> <li><code>float</code>: Accepts floating-point numbers.</li> <li><code>uuid</code>: Accepts UUIDs (unique identifiers).</li> <li><code>path</code>: Allows slashes in the variable.</li> </ul> <p>For example, consider the route:</p> <pre><code>@app.route('/exam/passers/list/&lt;float:rate&gt;/&lt;uuid:docId&gt;')\ndef report_exam_passers(rating: float, docId: uuid4 = None):\n    exams = list_passing_scores(rating)\n    return render_template('exam/list_exam_passers.html', exams=exams, docId=docId)\n</code></pre> <p>In this route: - <code>&lt;float:rate&gt;</code> ensures the <code>rate</code> is a float. - <code>&lt;uuid:docId&gt;</code> expects a UUID. - In the function, <code>rating</code> and <code>docId</code> hold the values passed in the URL.</p>"},{"location":"Python/Flask/dynamicroutes/#custom-path-variables","title":"Custom Path Variables","text":"<p>In some cases, Flask\u2019s built-in types may not suffice (e.g., <code>date</code>, <code>list</code>). Using unsupported types directly will result in an error (HTTP 500). To handle such cases, custom converters can be created using the <code>BaseConverter</code> class from Werkzeug.</p> <p>For example, if you need to handle a <code>date</code> type in the URL, you can create a custom converter like this:</p> <pre><code>from werkzeug.routing import BaseConverter\nfrom datetime import datetime\n\nclass DateConverter(BaseConverter):\n    def to_python(self, value):\n        return datetime.strptime(value, \"%Y-%m-%d\")\n</code></pre> <p>This converter uses the <code>to_python()</code> method to transform the string value in the URL (e.g., \"2024-10-22\") into a <code>datetime</code> object.</p>"},{"location":"Python/Flask/dynamicroutes/#registering-the-custom-converter","title":"Registering the Custom Converter","text":"<p>To use the custom converter, you must register it with Flask:</p> <pre><code>app = Flask(__name__)\napp.url_map.converters['date'] = DateConverter\n</code></pre> <p>Once registered, you can use it in routes:</p> <pre><code>@app.route('/certificate/&lt;string:name&gt;/&lt;string:course&gt;/&lt;date:accomplished_date&gt;')\ndef show_certification(name: str, course: str, accomplished_date: date):\n    return f\"&lt;h1&gt;Certificate of Accomplishment&lt;/h1&gt;&lt;p&gt;{name} completed {course} on {accomplished_date}&lt;/p&gt;\", 200\n</code></pre> <p>Here, <code>&lt;date:accomplished_date&gt;</code> uses the <code>DateConverter</code>, which converts the string in the URL into a Python <code>date</code>.</p>"},{"location":"Python/Flask/dynamicroutes/#summary-of-key-points","title":"Summary of Key Points","text":"<ol> <li>Dynamic URLs: Created using path variables in the format <code>&lt;type:variable&gt;</code>, allowing for flexible URLs.</li> <li>Data Types: Flask supports various built-in data types like <code>string</code>, <code>int</code>, <code>float</code>, <code>uuid</code>, and <code>path</code>.</li> <li>Custom Converters: For unsupported types (e.g., <code>date</code>), Flask can use custom converters via Werkzeug\u2019s <code>BaseConverter</code>.</li> <li>Usage: Register custom converters with the <code>app.url_map.converters</code> dictionary and use them in your routes.</li> </ol>"},{"location":"Python/Flask/fileuploads/","title":"File uploads","text":""},{"location":"Python/Flask/fileuploads/#1-setting-up-your-flask-application","title":"1. Setting Up Your Flask Application","text":"<p>First, you need to set up your Flask application and configure it to handle file uploads. Here\u2019s a simple configuration:</p> <pre><code>from flask import Flask\n\napp = Flask(__name__)\napp.config['UPLOAD_FOLDER'] = 'uploads/'  # Folder to store uploaded files\napp.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # Limit upload size to 16MB\n</code></pre>"},{"location":"Python/Flask/fileuploads/#2-creating-an-upload-form","title":"2. Creating an Upload Form","text":"<p>You can create an HTML form for file uploads. Using Tailwind CSS for styling, it might look like this:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Upload Image&lt;/title&gt;\n    &lt;link href=\"https://cdn.jsdelivr.net/npm/tailwindcss@2.0.0/dist/tailwind.min.css\" rel=\"stylesheet\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"container mx-auto p-4\"&gt;\n        &lt;h1 class=\"text-2xl\"&gt;Upload an Image&lt;/h1&gt;\n        &lt;form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"&gt;\n            &lt;input type=\"file\" name=\"file\" accept=\"image/*\" class=\"border rounded p-2\"&gt;\n            &lt;button type=\"submit\" class=\"bg-blue-500 text-white rounded p-2 mt-2\"&gt;Upload&lt;/button&gt;\n        &lt;/form&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"Python/Flask/fileuploads/#3-handling-file-uploads-in-flask","title":"3. Handling File Uploads in Flask","text":"<p>You\u2019ll need a route to handle the file upload. Here\u2019s an example:</p> <pre><code>from flask import request, redirect, url_for, render_template\nimport os\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return 'No file part'\n    file = request.files['file']\n\n    if file.filename == '':\n        return 'No selected file'\n\n    if file:\n        filename = secure_filename(file.filename)\n        file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\n        return redirect(url_for('upload_success'))\n\n@app.route('/upload/success')\ndef upload_success():\n    return 'File uploaded successfully!'\n</code></pre>"},{"location":"Python/Flask/fileuploads/#4-image-previews","title":"4. Image Previews","text":"<p>For image previews before upload, you can use JavaScript. Here's an example using plain JavaScript:</p> <pre><code>&lt;input type=\"file\" id=\"fileInput\" accept=\"image/*\" onchange=\"previewImage()\"&gt;\n&lt;img id=\"preview\" src=\"#\" alt=\"Image Preview\" style=\"display:none;\"&gt;\n\n&lt;script&gt;\nfunction previewImage() {\n    const file = document.getElementById('fileInput').files[0];\n    const reader = new FileReader();\n\n    reader.onloadend = function() {\n        const preview = document.getElementById('preview');\n        preview.src = reader.result;\n        preview.style.display = 'block';\n    }\n\n    if (file) {\n        reader.readAsDataURL(file);\n    }\n}\n&lt;/script&gt;\n</code></pre>"},{"location":"Python/Flask/fileuploads/#5-resizing-and-reorienting-images","title":"5. Resizing and Reorienting Images","text":"<p>For image processing, you can use the Pillow library. To install it, run:</p> <pre><code>pip install Pillow\n</code></pre> <p>Here\u2019s how you can resize and reorient images after upload:</p> <pre><code>from PIL import Image\n\ndef resize_image(file_path, output_size=(300, 300)):\n    with Image.open(file_path) as img:\n        img.thumbnail(output_size)\n        img.save(file_path)\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    # (previous code)\n\n    if file:\n        filename = secure_filename(file.filename)\n        file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n        file.save(file_path)\n\n        # Resize image\n        resize_image(file_path)\n\n        return redirect(url_for('upload_success'))\n</code></pre>"},{"location":"Python/Flask/fileuploads/#6-handling-orientation-issues","title":"6. Handling Orientation Issues","text":"<p>You can check the EXIF data of the image to handle orientation:</p> <pre><code>from PIL import ExifTags\n\ndef correct_image_orientation(file_path):\n    with Image.open(file_path) as img:\n        for orientation in ExifTags.TAGS.keys():\n            if ExifTags.TAGS[orientation] == 'Orientation':\n                break\n        exif = img._getexif()\n        if exif is not None:\n            orientation_value = exif.get(orientation)\n            if orientation_value is not None:\n                # Rotate image based on orientation_value\n                if orientation_value == 3:\n                    img = img.rotate(180, expand=True)\n                elif orientation_value == 6:\n                    img = img.rotate(270, expand=True)\n                elif orientation_value == 8:\n                    img = img.rotate(90, expand=True)\n        img.save(file_path)\n</code></pre>"},{"location":"Python/Flask/fileuploads/#7-integrating-everything","title":"7. Integrating Everything","text":"<p>Integrate the resizing and orientation correction in your upload handler:</p> <pre><code>@app.route('/upload', methods=['POST'])\ndef upload_file():\n    # (previous code)\n\n    if file:\n        filename = secure_filename(file.filename)\n        file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n        file.save(file_path)\n\n        # Resize and correct orientation\n        correct_image_orientation(file_path)\n        resize_image(file_path)\n\n        return redirect(url_for('upload_success'))\n</code></pre>"},{"location":"Python/Flask/fileuploads/#multiple-file-uploads","title":"Multiple file uploads","text":"<p>To implement multiple file uploads with previews in Flask, you can follow a similar approach as before but modify the HTML form and JavaScript to  accommodate multiple files. Here's a step-by-step guide:</p>"},{"location":"Python/Flask/fileuploads/#1-update-the-html-form","title":"1. Update the HTML Form","text":"<p>You need to allow multiple file uploads in the HTML form.  You can achieve this by adding the <code>multiple</code> attribute to the file input.  Here\u2019s how the updated form looks:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"UTF-8\"&gt;\n    &lt;title&gt;Upload Images&lt;/title&gt;\n    &lt;link href=\"https://cdn.jsdelivr.net/npm/tailwindcss@2.0.0/dist/tailwind.min.css\" rel=\"stylesheet\"&gt;\n    &lt;style&gt;\n        .preview {\n            display: inline-block;\n            margin: 10px;\n        }\n        .preview img {\n            max-width: 150px;\n            max-height: 150px;\n        }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div class=\"container mx-auto p-4\"&gt;\n        &lt;h1 class=\"text-2xl\"&gt;Upload Images&lt;/h1&gt;\n        &lt;form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"&gt;\n            &lt;input type=\"file\" id=\"fileInput\" name=\"files\" accept=\"image/*\" multiple class=\"border rounded p-2\"&gt;\n            &lt;div id=\"previewContainer\"&gt;&lt;/div&gt;\n            &lt;button type=\"submit\" class=\"bg-blue-500 text-white rounded p-2 mt-2\"&gt;Upload&lt;/button&gt;\n        &lt;/form&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n        function previewImages() {\n            const files = document.getElementById('fileInput').files;\n            const previewContainer = document.getElementById('previewContainer');\n            previewContainer.innerHTML = ''; // Clear previous previews\n\n            for (let i = 0; i &lt; files.length; i++) {\n                const reader = new FileReader();\n                reader.onloadend = function() {\n                    const div = document.createElement('div');\n                    div.className = 'preview';\n                    const img = document.createElement('img');\n                    img.src = reader.result;\n                    img.alt = 'Image Preview';\n                    div.appendChild(img);\n                    previewContainer.appendChild(div);\n                }\n                reader.readAsDataURL(files[i]);\n            }\n        }\n\n        document.getElementById('fileInput').addEventListener('change', previewImages);\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"Python/Flask/fileuploads/#2-handle-multiple-file-uploads-in-flask","title":"2. Handle Multiple File Uploads in Flask","text":"<p>Next, update your Flask route to handle multiple files. You can access the uploaded files from <code>request.files</code> and iterate through them. Here\u2019s the modified route:</p> <pre><code>from flask import request, redirect, url_for, render_template\nimport os\nfrom werkzeug.utils import secure_filename\n\n@app.route('/upload', methods=['POST'])\ndef upload_files():\n    if 'files' not in request.files:\n        return 'No file part'\n\n    files = request.files.getlist('files')  # Get list of uploaded files\n\n    if not files:\n        return 'No selected files'\n\n    uploaded_files = []\n\n    for file in files:\n        if file:\n            filename = secure_filename(file.filename)\n            file_path = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n            file.save(file_path)\n            uploaded_files.append(filename)  # Store uploaded filenames for later use\n\n            # You can also resize and correct orientation for each file\n            correct_image_orientation(file_path)\n            resize_image(file_path)\n\n    return redirect(url_for('upload_success'))\n\n@app.route('/upload/success')\ndef upload_success():\n    return 'Files uploaded successfully!'\n</code></pre>"},{"location":"Python/Flask/fileuploads/#3-image-resizing-and-orientation-correction","title":"3. Image Resizing and Orientation Correction","text":"<p>You can reuse the image resizing and orientation correction functions defined earlier. They will be called for each uploaded image inside the loop in the <code>upload_files</code> route.</p>"},{"location":"Python/Flask/fileuploads/#summary","title":"Summary","text":"<p>With these updates, you can now upload multiple images and display previews for each one. The backend can handle the uploaded files as a list, allowing you to perform any necessary processing (like resizing and correcting orientation) for each image individually. This approach ensures a smooth user experience, similar to what you might have implemented in Laravel and Livewire.</p>"},{"location":"Python/Flask/intro/","title":"Flask - Initial setup","text":"<pre><code>$ mkdir microblog\n$ cd microblog\n$ python3 -m venv venv\n$ source venv/bin/activate\n</code></pre> <p>What happens when you run /venv/bin/activate:</p> <ul> <li>This command temporarily modifies your shell's environment variables, particularly the PATH variable, so that the shell prioritizes the virtual environment's bin directory over the system-wide directories.</li> <li>This ensures that the Python interpreter and any packages you install come from this virtual environment, not from the system-wide Python installation.</li> <li>You'll notice the shell prompt changes to indicate the virtual environment is active, typically appearing as (venv).</li> </ul> <p>Deactivating the virtual environment:</p> <p>To exit the virtual environment and return to the system-wide Python environment, simply run: <code>deactivate</code></p> <p>Install flask</p> <p>To install Flask within the virtual environment, use: <code>(venv) $ pip install flask</code> Setting Up the Application Package</p> <p>Let's create a package called app, which will host the Flask application:</p> <p><code>(venv) $ mkdir app</code></p> <p>The <code>__init__.py</code>  file in the app package will initialize the Flask application:</p> <p>app/__init__.py -  Flask application instance<pre><code>from flask import Flask\napp = Flask(__name__)\nfrom app import routes\n</code></pre> Now, let's define the routes for the application: app/routes.py - the Home page route<pre><code>from app import app\n\n@app.route('/')\n@app.route('/index')\ndef index():\n    return \"Hello, World!\"\n</code></pre> Understanding the @app.route Decorators</p> <p>The @app.route lines above the index function are decorators\u2014a powerful feature of the Python language. </p> <p>Decorators allow you to modify or extend the behavior of functions or methods. </p> <p>In Flask, they are commonly used to register a function as a callback for a specific URL.</p> <ul> <li>The @app.route('/') decorator associates the root URL (/) with the index function.</li> <li>The second @app.route('/index') decorator associates the /index URL with the same function.</li> </ul> <p>This means that when a browser requests either / or /index, Flask invokes the index function and  sends the return value (\"Hello, World!\") as a response.</p> <p>Main Application Module</p> <p>Next, create the main module that will run the application:</p> <p>microblog.py: Main application module<pre><code>from app import app\n</code></pre> the project structure so far:<pre><code>microblog/\n  venv/\n  app/\n    __init__.py\n    routes.py\n  microblog.py\n</code></pre> Running the Application</p> <p>Flask needs to know how to import the application, which is specified by  setting the FLASK_APP environment variable:</p> <p><code>(venv) $ export FLASK_APP=microblog.py</code></p> <p><code>(venv) $ flask run --port 5001</code></p> <p>Persistent Environment Variables with .flaskenv</p> <p>Since environment variables aren't preserved across terminal sessions, setting FLASK_APP each time can be tedious.  To automate this, install the python-dotenv package:</p> <p><code>(venv) $ pip install python-dotenv</code></p> <p>Create a .flaskenv file in the project's root directory to store the environment variable:</p> <p><code># .flaskenv: Environment variables for Flask command FLASK_APP=microblog.py</code></p> <p>Now, when you run flask run, Flask will automatically read the .flaskenv file and apply the environment variables, simplifying your workflow.</p>"},{"location":"Python/Flask/intro/#housekeeping","title":"Housekeeping","text":"<p>Add a .gitignore and a requirements.txt</p> <p>requirements.txt: </p> <p>This file will list all the dependencies your project is using,  making it easier to replicate the environment later or share it with others. </p> <p>To generate it:</p> <p><code>(venv) $ pip freeze &gt; requirements.txt</code> This will store the current packages installed in your virtual environment (like Flask, python-dotenv, etc.) in requirements.txt , which others can install using:</p> <p><code>$ pip install -r requirements.txt</code> gitignore: </p> <p>This file will prevent sensitive or unnecessary files (like your venv directory) from being tracked in version control. </p> <p>Common items to add to .gitignore for a Flask project include:</p> <p><code>venv/ *.pyc __pycache__/ .flaskenv</code></p>"},{"location":"Python/Flask/requestandresponse/","title":"Managing Request and Response Data in Flask","text":"<p>Flask enables routing, which maps view functions to URLs, allowing views to handle incoming requests and outgoing responses effectively. Flask's <code>request</code> object serves as a proxy that provides access to various request-related details, such as cookies, headers, parameters, form data, and more. Importantly, Flask\u2019s view functions do not need to explicitly declare a <code>request</code> parameter, as Flask automatically provides access via <code>flask.request</code>.</p>"},{"location":"Python/Flask/requestandresponse/#retrieving-data-from-the-request-object","title":"Retrieving Data from the Request Object","text":"<p>The <code>request</code> object offers various attributes and methods to access data sent with an HTTP request:</p> <ul> <li><code>request.args</code>: Holds query parameters from the URL (e.g., data after the \"?\" in the URL).</li> <li><code>request.form</code>: Contains form data (submitted via POST method).</li> <li><code>request.data</code>: Holds raw request data in a byte stream, typically used when Flask can\u2019t parse the data.</li> <li><code>request.files</code>: Stores file objects sent via forms with <code>enctype=\"multipart/form-data\"</code>.</li> <li><code>request.json</code>: Retrieves JSON payloads sent with <code>Content-Type: application/json</code>.</li> <li><code>request.method</code>: Returns the HTTP method (GET, POST, etc.) used in the request.</li> <li><code>request.headers</code>: Accesses HTTP request headers.</li> <li><code>request.cookies</code>: Retrieves cookies sent by the client.</li> </ul>"},{"location":"Python/Flask/requestandresponse/#example-handling-get-and-post-requests","title":"Example: Handling GET and POST Requests","text":"<p>Here\u2019s an example of a login function that uses <code>request.args</code> to retrieve URL parameters:</p> <p><pre><code>@app.route('/login/params')\ndef login_with_params():\n    username = request.args['username']\n    password = request.args['password']\n    result = validate_user(username, password)\n    if result:\n        return Response(response=render_template('/main.html'), status=200, content_type='text/html')\n    else:\n        return redirect('/error')\n</code></pre> This function accesses query parameters (e.g., <code>/login/params?username=user&amp;password=pass</code>) to authenticate a user.</p>"},{"location":"Python/Flask/requestandresponse/#combining-get-and-post-methods","title":"Combining GET and POST Methods","text":"<p>The following view function handles both GET and POST requests, using <code>request.method</code> to determine the type of request:</p> <pre><code>@app.route('/signup/approve', methods=['POST'])\n@app.route('/signup/approve/&lt;int:utype&gt;', methods=['GET'])\ndef signup_approve(utype: int = None):\n    if request.method == 'GET':\n        id = request.args['id']\n        user = select_single_signup(id)\n        # Handle GET request logic here...\n    else:\n        utype = int(utype)\n        data = request.get_data().decode('utf-8')\n        user_data = dict(parse_qsl(data))\n        if utype == 1:\n            model = AdminUser(**user_data)\n        elif utype == 2:\n            model = CounselorUser(**user_data)\n        elif utype == 3:\n            model = PatientUser(**user_data)\n        user_approval_service(utype, model)\n        return render_template('approved_user.html', message='approved'), 200\n</code></pre> <ul> <li>GET Request: Retrieves query parameters via <code>request.args['id']</code> and performs logic based on the user type.</li> <li>POST Request: Receives form data as a byte stream using <code>request.get_data()</code>, decodes it, and processes the user data.</li> </ul>"},{"location":"Python/Flask/requestandresponse/#key-points","title":"Key Points:","text":"<ul> <li>Flask uses the <code>request</code> object to simplify request management, including retrieving query parameters, form data, and headers.</li> <li>Dual routing with GET and POST allows handling both methods within a single view function, often using <code>request.method</code> to distinguish between them.</li> <li><code>request.get_data()</code> provides access to raw request body data, useful for handling non-standard data types, like URL-encoded byte streams.</li> </ul>"},{"location":"Python/Flask/requestandresponse/#creating-the-response-object-in-flask","title":"Creating the Response Object in Flask","text":"<p>In Flask, the <code>Response</code> object is essential for generating responses to client requests. This object encapsulates the HTTP response, including the content, status code, and headers. Here\u2019s how to create and manage responses in Flask:</p>"},{"location":"Python/Flask/requestandresponse/#basic-response-creation","title":"Basic Response Creation","text":"<p>A view function can create a response using the <code>Response</code> class, specifying the necessary parameters:</p> <ul> <li><code>response</code>: The main content of the response, which can be a string, byte stream, or iterable.</li> <li><code>status</code>: An integer or string representing the HTTP status code (e.g., 200 for success).</li> <li><code>content_type</code>: Specifies the MIME type of the response (e.g., <code>text/html</code>).</li> <li><code>headers</code>: An optional dictionary of additional headers for the response.</li> </ul> <p>Example: <pre><code>@app.route('/admin/users/list')\ndef generate_admin_users():\n    users = select_admin_join_user()\n    user_list = [list(rec) for rec in users]\n    content = '''&lt;html&gt;&lt;head&gt;\n    &lt;title&gt;User List&lt;/title&gt;\n    &lt;/head&gt;&lt;body&gt;\n    &lt;h1&gt;List of Users&lt;/h1&gt;\n    &lt;p&gt;{}&lt;/p&gt;\n    &lt;/body&gt;&lt;/html&gt;\n    '''.format(user_list)\n    resp = Response(response=content, status=200, content_type='text/html')\n    return resp\n</code></pre></p>"},{"location":"Python/Flask/requestandresponse/#rendering-html-templates","title":"Rendering HTML Templates","text":"<p>For rendering HTML content, Flask provides the <code>render_template()</code> method, which simplifies response creation. It automatically generates a <code>Response</code> object from the rendered template and can include context data.</p> <p>Example: <pre><code>@app.route('/signup/form', methods=['GET'])\ndef signup_users_form():\n    return render_template('add_signup.html'), 200\n</code></pre></p> <p>Flask also allows for returning the result of <code>render_template()</code> directly, making code cleaner and more concise.</p>"},{"location":"Python/Flask/requestandresponse/#jinja2-templating-engine","title":"Jinja2 Templating Engine","text":"<p>Flask uses Jinja2, a powerful templating engine, for generating HTML and other formats. It allows dynamic rendering of templates with context data, enabling more complex user interfaces.</p>"},{"location":"Python/Flask/requestandresponse/#modifying-responses-with-make_response","title":"Modifying Responses with <code>make_response()</code>","text":"<p>The <code>make_response()</code> utility allows developers to modify the response by adjusting headers and cookies before sending it to the client. This is particularly useful when responses need to include specific headers, like for file downloads.</p> <p>Example: <pre><code>@app.route('/exam/details/list')\ndef report_exam_list():\n    exams = list_exam_details()\n    response = make_response(render_template('exam/list_exams.html', exams=exams), 200)\n    response.headers['Content-Type'] = 'application/vnd.ms-excel'\n    response.headers['Content-Disposition'] = 'attachment;filename=questions.xls'\n    return response\n</code></pre></p>"},{"location":"Python/Flask/requestandresponse/#adding-and-retrieving-cookies","title":"Adding and Retrieving Cookies","text":"<p>Flask can also manage cookies through the response object:</p> <ul> <li>Setting a cookie: Use the <code>set_cookie()</code> method.</li> <li>Retrieving cookies: Use <code>request.cookies.get()</code> to access cookie values.</li> </ul> <p>Example: <pre><code>@app.route('/exam/assign', methods=['GET', 'POST'])\ndef assign_exam():\n    if request.method == 'GET':\n        cids = list_cid()\n        pids = list_pid()\n        response = make_response(render_template('exam/assign_exam_form.html', pids=pids, cids=cids), 200)\n        response.set_cookie('exam_token', str(uuid4()))\n        return response\n    else:\n        # Handle POST logic...\n</code></pre></p>"},{"location":"Python/Flask/requestandresponse/#key-points_1","title":"Key Points:","text":"<ul> <li>The <code>Response</code> object is crucial for constructing responses in Flask, containing the response content, status, and headers.</li> <li><code>render_template()</code> simplifies the process of returning HTML responses by generating the necessary <code>Response</code> objects automatically.</li> <li>Flask allows for extensive customization of responses using <code>make_response()</code> and cookie management, providing flexibility in handling client requests and server responses.</li> </ul>"},{"location":"Python/Flask/routing/","title":"Routing in Flask","text":"<p>Here's how assigning URLs externally using <code>add_url_rule()</code> works in Flask:</p>"},{"location":"Python/Flask/routing/#usual-method-approute-decorator","title":"Usual Method: <code>@app.route()</code> Decorator","text":"<ul> <li> <p>Normally, when defining a route (a URL that connects to a specific function), we use the <code>@app.route()</code> decorator above a function. For example:</p> <pre><code>@app.route('/hello')\ndef say_hello():\n    return \"Hello, World!\"\n</code></pre> </li> <li> <p>Here, the URL <code>/hello</code> is directly tied to the <code>say_hello</code> function using the decorator.</p> </li> </ul>"},{"location":"Python/Flask/routing/#alternative-method-add_url_rule","title":"Alternative Method: <code>add_url_rule()</code>","text":"<ul> <li> <p><code>add_url_rule()</code> is another way to register a URL to a function without using decorators. It's a more flexible approach.</p> </li> <li> <p>With <code>add_url_rule()</code>, you manually link a URL to a function. This can be useful if you prefer to keep your URL rules separate from your function definitions.</p> </li> </ul>"},{"location":"Python/Flask/routing/#how-it-works","title":"How it Works:","text":"<ol> <li>URL Pattern: You specify the URL pattern (with optional path variables).</li> <li>Function Name: You give the URL rule a name, often the same as the function.</li> <li>View Function: You pass the function that will handle requests to that URL.</li> </ol> <p>Here\u2019s an example using <code>add_url_rule()</code>:</p> <pre><code>app = Flask(__name__)\n\n# Define a function to handle a request to this URL\ndef show_honor_dismissal(counselor: str, effective_date: str, patient: str):\n    letter = f\"\"\"\n    &lt;html&gt;\n    &lt;body&gt;\n        &lt;h1&gt;Termination of Consultation&lt;/h1&gt;\n        &lt;p&gt;From: {counselor}&lt;/p&gt;\n        &lt;p&gt;Date: {effective_date}&lt;/p&gt;\n        &lt;p&gt;To: {patient}&lt;/p&gt;\n        &lt;p&gt;Subject: Termination of consultation&lt;/p&gt;\n        &lt;p&gt;Dear {patient},&lt;/p&gt;\n        &lt;p&gt;Yours Sincerely,&lt;/p&gt;\n        &lt;p&gt;{counselor}&lt;/p&gt;\n    &lt;/body&gt;\n    &lt;/html&gt;\n    \"\"\"\n    return letter, 200\n\n# Bind the URL to the function externally using add_url_rule()\napp.add_url_rule(\n    '/certificate/terminate/&lt;string:counselor&gt;/&lt;string:effective_date&gt;/&lt;string:patient&gt;',\n    'show_honor_dismissal',    # Name of the rule\n    show_honor_dismissal       # The actual function to call\n)\n</code></pre>"},{"location":"Python/Flask/routing/#key-points","title":"Key Points:","text":"<ul> <li> <p>URL Pattern: The first argument is the URL (<code>/certificate/terminate/...</code>) where <code>&lt;string:counselor&gt;</code>, <code>&lt;string:effective_date&gt;</code>, and <code>&lt;string:patient&gt;</code> are variables that will be passed to the function.</p> </li> <li> <p>Rule Name: The second argument (<code>'show_honor_dismissal'</code>) is a name for the route. This is usually the same as the function name but can be anything.</p> </li> <li> <p>View Function: The third argument (<code>show_honor_dismissal</code>) is the function that handles the request when someone visits that URL.</p> </li> </ul>"},{"location":"Python/Flask/routing/#why-use-add_url_rule","title":"Why Use <code>add_url_rule()</code>?","text":"<ul> <li> <p>Separation of Concerns: It lets you keep your URL mappings and function definitions separate. This can make your code cleaner if you're dealing with many routes.</p> </li> <li> <p>Dynamic URLs: You can define more dynamic or flexible routes in one place instead of using multiple decorators.</p> </li> </ul>"},{"location":"Python/Flask/routing/#use-case","title":"Use Case:","text":"<ul> <li>This method is not only for simple function-based views but also class-based views, where you might want more control over URL handling.</li> </ul> <p>In summary, <code>add_url_rule()</code> is just a different way of linking URLs to functions, offering more flexibility than decorators when managing routes, especially in more complex or structured projects.</p>"},{"location":"Python/Flask/templates/","title":"Flask - Templates","text":"<p>In Flask, templating is the process of dynamically generating HTML content by embedding Python code within HTML files.</p> <p>Flask uses Jinja2 as its templating engine, allowing you to create templates that can render variables,  use control structures (like loops and conditionals),  and even extend layouts to reuse common elements across different pages.</p> <p>Key concepts in Flask templating: 1. Templates: HTML files with placeholders for dynamic content, typically stored in a <code>templates/</code> folder.</p> <ol> <li> <p>Rendering templates: Using the <code>render_template()</code> function, Flask processes a template and replaces placeholders with actual data.</p> <pre><code>from flask import render_template\n\n@app.route('/')\ndef index():\n    return render_template('index.html', title='Home Page', user='Alice')\n</code></pre> <p>In this example, Flask looks for an <code>index.html</code> template and passes the <code>title</code> and <code>user</code> variables to it.</p> </li> <li> <p>Variables: Inside a template, you can use variables enclosed in double curly braces to insert data.    <pre><code>&lt;h1&gt;Welcome, {{ user }}!&lt;/h1&gt;\n</code></pre></p> </li> <li> <p>Control structures: You can use Jinja2\u2019s control structures like <code>for</code> loops or <code>if</code> statements to dynamically control the content.    <pre><code>{% if user %}\n&lt;h1&gt;Hello, {{ user }}!&lt;/h1&gt;\n{% else %}\n&lt;h1&gt;Hello, stranger!&lt;/h1&gt;\n{% endif %}\n</code></pre></p> </li> <li> <p>Template inheritance: You can create a base template that contains common layout (like headers and footers) and have other templates extend it.    <pre><code>&lt;!-- base.html --&gt;\n&lt;html&gt;\n  &lt;head&gt;&lt;title&gt;{% block title %}My App{% endblock %}&lt;/title&gt;&lt;/head&gt;\n  &lt;body&gt;\n    &lt;header&gt;Header&lt;/header&gt;\n    &lt;div&gt;{% block content %}{% endblock %}&lt;/div&gt;\n    &lt;footer&gt;Footer&lt;/footer&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <pre><code>&lt;!-- index.html --&gt;\n{% extends 'base.html' %}\n{% block title %}Home{% endblock %}\n{% block content %}\n&lt;h1&gt;Welcome to the homepage!&lt;/h1&gt;\n{% endblock %}\n</code></pre></p> </li> </ol> <p>Templating in Flask is a powerful way to separate the logic of your application from the presentation layer, making your app more maintainable and scalable.</p>"},{"location":"Python/Object%20Oriented%20Programming/classes/","title":"Python Classes: A Summary","text":"<p>In Python, classes are used to create objects that encapsulate state (data/attributes) and behaviors (methods/functions). Objects created from a class are called instances.</p> <p>Naming </p> <pre><code>classes - The class name must follow standard Python variable naming rules \n(it must start with a letter or underscore, and can\nonly be comprised of letters, underscores, or numbers).\n\nIn addition, the Python style guide (search the web for PEP 8)\nrecommends that classes should be named using what PEP 8\ncalls CapWords notation (start with a capital letter; any subsequent\nwords should also start with a capital).\n</code></pre>"},{"location":"Python/Object%20Oriented%20Programming/classes/#1-class-behavior-and-state","title":"1. Class Behavior and State","text":"<ul> <li> <p>State is represented by attributes (variables) that belong to the class.</p> </li> <li> <p>Behavior is represented by methods (functions) that belong to the class.</p> </li> </ul> <p>Example: <pre><code>class Dog:\n    # Initializing state with the constructor (__init__)\n    def __init__(self, name, breed):\n        self.name = name  # instance attribute\n        self.breed = breed  # instance attribute\n\n    # Behavior method\n    def bark(self):\n        return f\"{self.name} says woof!\"\n</code></pre></p> <ul> <li> <p>State: The dog's name and breed are attributes.</p> </li> <li> <p>Behavior: The bark method is a behavior.</p> </li> </ul>"},{"location":"Python/Object%20Oriented%20Programming/classes/#2-class-methods-and-attributes","title":"2. Class Methods and Attributes","text":"<ul> <li>Attributes are variables that belong to the class or the instance of a class.</li> <li>Methods are functions that define the behaviors of the class.</li> <li>Methods can take self as a parameter to access or modify instance attributes.</li> </ul> <p>Example: <pre><code>class Car:\n    # Class attribute (shared by all instances)\n    wheels = 4\n\n    def __init__(self, make, model):\n        # Instance attributes (unique to each instance)\n        self.make = make\n        self.model = model\n\n    # Instance method\n    def description(self):\n        return f\"{self.make} {self.model} has {self.wheels} wheels.\"\n</code></pre></p> <ul> <li>Class Attribute: wheels is shared by all Car instances.</li> <li>Instance Attributes: make and model are unique to each car.</li> <li>Instance Method: description returns a formatted string.</li> <li>A method is a function you invoke on an instance of the class or the class itself.</li> <li>A method that is invoked on an instance is sometimes called an instance method.</li> <li>You can also invoke a method directly on a class, in which case it is called a class method or a static method.</li> <li>Attributes that take data values on a per-instance basis are frequently referred to as instance variables.</li> <li>Attributes that take on values on a per-class basis are called class attributes or static attributes or class variables.</li> </ul>"},{"location":"Python/Object%20Oriented%20Programming/classes/#3-creating-and-instantiating-classes","title":"3. Creating and Instantiating Classes","text":"<p>You can create (define) a class and then instantiate (create objects from) the class. Example:</p> <pre><code># Defining the class\nclass Cat:\n    def __init__(self, name, color):\n        self.name = name\n        self.color = color\n\n    def meow(self):\n        return f\"{self.name} says meow!\"\n\n# Instantiating (creating objects)\ncat1 = Cat(\"Whiskers\", \"white\")\ncat2 = Cat(\"Shadow\", \"black\")\n\nprint(cat1.meow())  # Output: Whiskers says meow!\nprint(cat2.meow())  # Output: Shadow says meow!\n</code></pre>"},{"location":"Python/Object%20Oriented%20Programming/classes/#4-instance-methods","title":"4. Instance Methods","text":"<ul> <li>Instance methods can modify an instance's state (attributes) or perform actions based on that instance.</li> <li>These methods have access to the instance through the self parameter.</li> </ul> <p>Example: <pre><code>class Counter:\n    def __init__(self):\n        self.count = 0  # Initializing state\n\n    # Instance method to increment count\n    def increment(self):\n        self.count += 1\n\n    # Instance method to get the current count\n    def get_count(self):\n        return self.count\n\n# Creating an instance of Counter\ncounter = Counter()\n\n# Using instance methods\ncounter.increment()\ncounter.increment()\nprint(counter.get_count())  # Output: 2\n</code></pre></p> <ul> <li>increment method changes the instance state by increasing count.</li> <li>get_count retrieves the current count.</li> </ul>"},{"location":"Python/Object%20Oriented%20Programming/classes/#5-accessing-methods-and-attributes","title":"5. Accessing Methods and Attributes","text":"<ul> <li>Instance methods are called on the object (instance).</li> <li>Attributes can be accessed directly using the dot notation.</li> </ul> <p>Example: <pre><code>class Book:\n    def __init__(self, title, author):\n        self.title = title\n        self.author = author\n\n    def info(self):\n        return f\"'{self.title}' by {self.author}\"\n\n# Create an instance\nmy_book = Book(\"1984\", \"George Orwell\")\n\n# Access instance attributes\nprint(my_book.title)  # Output: 1984\nprint(my_book.author)  # Output: George Orwell\n\n# Call instance method\nprint(my_book.info())  # Output: '1984' by George Orwell\n</code></pre></p>"},{"location":"Python/Object%20Oriented%20Programming/classes/#6-class-vs-instance-attributes","title":"6. Class vs. Instance Attributes","text":"<ul> <li>Class attributes are shared across all instances.</li> <li>Instance attributes are unique to each instance.</li> </ul> <p>Example: <pre><code>class Tree:\n    # Class attribute\n    species = \"Oak\"\n\n    def __init__(self, height):\n        # Instance attribute\n        self.height = height\n\n# Create two instances\ntree1 = Tree(10)\ntree2 = Tree(20)\n\n# Access class and instance attributes\nprint(tree1.species)  # Output: Oak (shared)\nprint(tree1.height)   # Output: 10 (unique)\nprint(tree2.height)   # Output: 20 (unique)\n</code></pre> Summary:</p> <ul> <li>Attributes store the state of the class or object.</li> <li>Methods define the behavior of the class or object.</li> <li>Classes are instantiated to create objects.</li> <li>Objects can access methods and attributes using dot notation.</li> </ul>"},{"location":"Python/Object%20Oriented%20Programming/classes/#7-encapsulation-in-python","title":"7. Encapsulation in Python","text":"<p>Encapsulation is one of the fundamental concepts of Object-Oriented Programming (OOP). </p> <p>It enables us to hide the internal complexity of an object and protect the integrity of the data. </p> <p>This is achieved by restricting direct access to some of the object's components. </p> <p>With appropriate data encapsulation, a class will present a well-defined public interface for its clients, the users of the class.</p> <p>A client should only access those data attributes and invoke those methods that are in the public interface.</p>"},{"location":"Python/Object%20Oriented%20Programming/classes/#71-advantages-of-encapsulation","title":"7.1 Advantages of Encapsulation:","text":"<ol> <li>Simplifies object usage: A developer can use an object without needing to understand its internal working.</li> <li>Ease of maintenance: Any changes to the internals can be made without affecting the outside code as long as the public interface remains consistent.</li> </ol> <p>Encapsulation is often discussed alongside abstraction, but they are not the same. Encapsulation deals with restricting access to internal data, whereas abstraction deals with exposing only relevant aspects to the user.</p>"},{"location":"Python/Object%20Oriented%20Programming/classes/#72-data-hiding-with-getters-and-setters","title":"7.2 Data Hiding with Getters and Setters","text":"<p>In Python, encapsulation is usually achieved by making attributes private and controlling their access through getter and setter methods. This allows for validation and restricting the type of data that is being assigned.</p> <p><pre><code>class MyClass:\n    def __init__(self):\n        self._age = None  # Private-like attribute\n\n    # Setter for age\n    def set_age(self, num):\n        if isinstance(num, int) and num &gt; 0:\n            self._age = num\n        else:\n            raise ValueError(\"Age must be a positive integer.\")\n\n    # Getter for age\n    def get_age(self):\n        return self._age\n\n# Example usage\nperson = MyClass()\nperson.set_age(45)\nprint(person.get_age())  # Outputs: 45\n</code></pre> In the code above, _age is considered a protected attribute (by convention, not enforced). The setter (set_age) ensures that only valid data is assigned to self._age. Problem of Invalid Input</p> <p>Without proper validation in the setter, an invalid value could be assigned to the attribute, like a string instead of an integer: <pre><code># Example of an invalid input\nperson.set_age(\"Forty Five\")  # This raises an error now!\n</code></pre> By using encapsulation and adding validation inside the setter, we ensure that only valid values are assigned to self._age. Initialization with init Constructor</p> <p>The init method in Python is the constructor for a class. It is automatically invoked when an object is instantiated and is typically used to initialize attributes of the object. <pre><code>class MyClass:\n    def __init__(self, value):\n        self.value = value  # Instance attribute initialized\n\n# Creating an instance of MyClass\nx = MyClass(10)\nprint(x.value)  # Outputs: 10\n</code></pre> Here, init initializes the value attribute with whatever argument is passed during instantiation. Without init, attributes could be added after instantiation, but it's better practice to use init for predictable and consistent initialization. Constructor with Multiple Arguments</p> <p>The init method can accept multiple arguments to initialize several attributes at once. <pre><code>class MyClass:\n    def __init__(self, aaa, bbb):\n        self.a = aaa\n        self.b = bbb\n\nx = MyClass(4.5, 3)\nprint(x.a, x.b)  # Outputs: 4.5 3\n</code></pre> Class Attributes vs Instance Attributes - Class attributes are shared by all instances of the class. - Instance attributes are unique to each instance.</p>"},{"location":"Python/Object%20Oriented%20Programming/classes/#73-class-attributes","title":"7.3 Class Attributes","text":"<p>Class attributes are defined directly in the class body and are shared across all instances of the class.</p> <p><pre><code>class MyClass:\n    age = 21  # Class attribute\n\n# Accessing class attribute through the class itself\nprint(MyClass.age)  # Outputs: 21\n\n# Accessing class attribute through an instance\nx = MyClass()\nprint(x.age)  # Outputs: 21\n</code></pre> In the example above, age is a class attribute shared by all instances of MyClass. Instance Attributes</p> <p>Instance attributes are defined inside the init method or another instance method. They are unique to each instance.</p> <pre><code>class MyClass:\n    def __init__(self, value):\n        self.value = value  # Instance attribute\n\n# Creating instances with different values\nx = MyClass(10)\ny = MyClass(20)\n\n# Accessing instance attributes\nprint(x.value)  # Outputs: 10\nprint(y.value)  # Outputs: 20\n</code></pre>"},{"location":"Python/Object%20Oriented%20Programming/classes/#74-overriding-class-attributes-in-instances","title":"7.4 Overriding Class Attributes in Instances","text":"<p>It\u2019s possible to override class attributes in an instance:</p> <pre><code>class MyClass:\n    classy = 'class value'  # Class attribute\n\n# Instance creation\ndd = MyClass()\nprint(dd.classy)  # Outputs: 'class value'\n\n# Overriding class attribute for this instance\ndd.classy = \"instance value\"\nprint(dd.classy)  # Outputs: 'instance value'\n\n# Deleting the instance attribute reverts to the class attribute\ndel dd.classy\nprint(dd.classy)  # Outputs: 'class value'\n</code></pre>"},{"location":"Python/Object%20Oriented%20Programming/classes/#75-working-with-class-and-instance-data","title":"7.5 Working with Class and Instance Data","text":"<p>Instances can access class data as well as their own instance data. Here\u2019s an example of how both are used:</p> <pre><code>class InstanceCounter:\n    count = 0  # Class attribute shared by all instances\n\n    def __init__(self, val):\n        self.val = val  # Instance attribute unique to each instance\n        InstanceCounter.count += 1  # Incrementing class attribute count\n\n    def get_count(self):\n        return InstanceCounter.count\n\n# Creating instances\na = InstanceCounter(9)\nb = InstanceCounter(18)\nc = InstanceCounter(27)\n\n# Accessing both instance and class data\nfor obj in (a, b, c):\n    print(f'val of obj: {obj.val}')  # Outputs: 9, 18, 27\n    print(f'count: {obj.get_count()}')  # Outputs: 3 for all, since it's class-wide\n</code></pre>"},{"location":"Python/Object%20Oriented%20Programming/classes/#76-summary","title":"7.6 Summary","text":"<p>Encapsulation allows you to restrict access to internal data and ensure that it is only  modified in controlled ways (using setters and getters).</p> <p>init Constructor is used to initialize an object\u2019s attributes upon creation.</p> <p>Class Attributes are shared across all instances, while Instance Attributes are unique to each instance.</p> <p>Encapsulation combined with class and instance data management ensures a cleaner and more reliable design.</p>"},{"location":"Python/Object%20Oriented%20Programming/classes/#8-object-orientated-shortcuts","title":"8 Object orientated shortcuts","text":"Built-in Function Description Example <code>abs()</code> Returns the absolute value of a number. <code>abs(-5)</code> returns <code>5</code> <code>all()</code> Returns <code>True</code> if all elements are true. <code>all([True, True, False])</code> returns <code>False</code> <code>any()</code> Returns <code>True</code> if any element is true. <code>any([False, True, False])</code> returns <code>True</code> <code>ascii()</code> Returns a string containing a printable <code>ascii('\u00e9')</code> returns <code>\"'\\\\xe9'\"</code> representation of an object. <code>bin()</code> Converts an integer to a binary string. <code>bin(10)</code> returns <code>'0b1010'</code> <code>bool()</code> Converts a value to a Boolean. <code>bool(0)</code> returns <code>False</code> <code>bytearray()</code> Returns a new array of bytes. <code>bytearray([50])</code> returns <code>bytearray(b'2')</code> <code>bytes()</code> Returns a bytes object. <code>bytes(\"hello\", \"utf-8\")</code> returns <code>b'hello'</code> <code>callable()</code> Checks if the object appears callable. <code>callable(abs)</code> returns <code>True</code> <code>chr()</code> Returns the string representing a character <code>chr(97)</code> returns <code>'a'</code> whose Unicode code point is the integer. <code>classmethod()</code> Transforms a method into a class method. <code>class MyClass: @classmethod def my_method(cls): pass</code> <code>compile()</code> Compiles source into a code object. <code>compile('print(\"Hello\")', '', 'exec')</code> <code>complex()</code> Creates a complex number. <code>complex(1, 2)</code> returns <code>(1+2j)</code> <code>delattr()</code> Deletes an attribute from an object. <code>delattr(obj, 'attr')</code> deletes the attribute <code>attr</code> <code>dict()</code> Creates a new dictionary. <code>dict(a=1, b=2)</code> returns <code>{'a': 1, 'b': 2}</code> <code>divmod()</code> Returns a tuple of quotient and remainder. <code>divmod(10, 3)</code> returns <code>(3, 1)</code> <code>enumerate()</code> Adds a counter to an iterable. <code>list(enumerate(['a', 'b', 'c']))</code> returns <code>[(0, 'a'), (1, 'b'), (2, 'c')]</code> <code>eval()</code> Evaluates a string as a Python expression. <code>eval('2 + 2')</code> returns <code>4</code> <code>exec()</code> Executes a dynamically created Python code. <code>exec('a = 5')</code> sets <code>a</code> to <code>5</code> <code>filter()</code> Filters elements from an iterable. <code>list(filter(lambda x: x &gt; 0, [-2, -1, 0, 1, 2]))</code> returns <code>[1, 2]</code> <code>float()</code> Converts a string or integer to a float. <code>float('3.14')</code> returns <code>3.14</code> <code>format()</code> Formats a value into a string. <code>format(123, 'd')</code> returns <code>'123'</code> <code>frozenset()</code> Creates an immutable set. <code>frozenset([1, 2, 2, 3])</code> returns <code>frozenset({1, 2, 3})</code> <code>getattr()</code> Gets the value of an object's attribute. <code>getattr(obj, 'attr', default)</code> gets <code>attr</code>, or <code>default</code> if not found <code>globals()</code> Returns a dictionary of the current global <code>globals()</code> returns global symbol table symbol table. <code>hasattr()</code> Checks if an object has a specified attribute. <code>hasattr(obj, 'attr')</code> returns <code>True</code> or <code>False</code> <code>help()</code> Invokes the built-in help system. <code>help(str)</code> provides documentation for the string class <code>hex()</code> Converts an integer to a hexadecimal string. <code>hex(255)</code> returns <code>'0xff'</code> <code>id()</code> Returns the identity of an object. <code>id(obj)</code> returns unique identifier for <code>obj</code> <code>input()</code> Reads a line from input. <code>input(\"Enter something: \")</code> reads user input <code>int()</code> Converts a number or string to an integer. <code>int('10')</code> returns <code>10</code> <code>isinstance()</code> Checks if an object is an instance of a class. <code>isinstance(5, int)</code> returns <code>True</code> <code>issubclass()</code> Checks if a class is a subclass of another. <code>issubclass(bool, int)</code> returns <code>True</code> <code>len()</code> Returns the length of an object. <code>len([1, 2, 3])</code> returns <code>3</code> <code>list()</code> Creates a new list. <code>list((1, 2, 3))</code> returns <code>[1, 2, 3]</code> <code>map()</code> Applies a function to all items in an iterable. <code>list(map(str, [1, 2, 3]))</code> returns <code>['1', '2', '3']</code> <code>max()</code> Returns the largest item in an iterable. <code>max([1, 2, 3])</code> returns <code>3</code> <code>memoryview()</code> Creates a memory view object. <code>memoryview(b'abc')</code> returns <code>&lt;memory at ...&gt;</code> <code>min()</code> Returns the smallest item in an iterable. <code>min([1, 2, 3])</code> returns <code>1</code> <code>next()</code> Retrieves the next item from an iterator. <code>next(iter([1, 2, 3]))</code> returns <code>1</code> <code>open()</code> Opens a file and returns a file object. <code>open('file.txt', 'r')</code> opens <code>file.txt</code> for reading <code>ord()</code> Returns the Unicode code point for a character. <code>ord('a')</code> returns <code>97</code> <code>pow()</code> Returns a number raised to the power of another. <code>pow(2, 3)</code> returns <code>8</code> <code>print()</code> Prints the specified message to the console. <code>print('Hello, World!')</code> outputs <code>Hello, World!</code> <code>property()</code> Returns a property attribute. <code>class C: x = property()</code> defines a property <code>x</code> <code>range()</code> Generates a sequence of numbers. <code>list(range(5))</code> returns <code>[0, 1, 2, 3, 4]</code> <code>repr()</code> Returns a string representation of an object. <code>repr('hello')</code> returns <code>\"hello\"</code> <code>reversed()</code> Returns a reverse iterator. <code>list(reversed([1, 2, 3]))</code> returns <code>[3, 2, 1]</code> <code>round()</code> Rounds a number to a specified number of decimals. <code>round(3.14159, 2)</code> returns <code>3.14</code> <code>set()</code> Creates a new set. <code>set([1, 2, 2, 3])</code> returns <code>{1, 2, 3}</code> <code>setattr()</code> Sets the value of an object's attribute. <code>setattr(obj, 'attr', value)</code> sets <code>attr</code> to <code>value</code> <code>slice()</code> Creates a slice object. <code>slice(1, 5)</code> creates a slice from index 1 to 4 <code>sorted()</code> Returns a sorted list from an iterable. <code>sorted([3, 1, 2])</code> returns <code>[1, 2, 3]</code> <code>staticmethod()</code> Transforms a method into a static method. <code>class MyClass: @staticmethod def my_method(): pass</code> <code>str()</code> Converts an object to a string. <code>str(123)</code> returns <code>'123'</code> <code>sum()</code> Sums items of an iterable. <code>sum([1, 2, 3])</code> returns <code>6</code> <code>super()</code> Returns a temporary object of the superclass. <code>super(MyClass, self).method()</code> calls superclass method <code>tuple()</code> Creates a new tuple. <code>tuple([1, 2, 3])</code> returns <code>(1, 2, 3)</code> <code>type()</code> Returns the type of an object. <code>type(5)</code> returns <code>&lt;class 'int'&gt;</code> <code>vars()</code> Returns the <code>__dict__</code> attribute of an object. <code>vars(obj)</code> returns the <code>__dict__</code> of <code>obj</code> <code>zip()</code> Combines iterables into tuples. <code>list(zip([1, 2], ['a', 'b']))</code> returns <code>[(1, 'a'), (2, 'b')]</code> <code>__import__()</code> Imports a module. <code>__import__('math')</code> imports the <code>math</code> module"},{"location":"Python/Object%20Oriented%20Programming/classes/#81-callable-objects","title":"8.1 Callable Objects","text":"<p>Callable Objects: Any object that implements the call() method can be invoked as if it were a function. This means you can call an instance of such an object using the usual function call syntax.</p> <p>Use Cases: Callable objects can be useful for encapsulating behavior in a more object-oriented way. For example, they can maintain state or configure behavior through instance variables while still providing a clear function-like interface.</p> <p>Example of a Callable Object</p> <p>Here's a simple example demonstrating a callable object in Python:</p> <pre><code>class Multiplier:\n    def __init__(self, factor):\n        # Initialize the multiplier factor\n        self.factor = factor\n\n    def __call__(self, number):\n        # Return the product of the input number and the factor\n        return number * self.factor\n\n# Create an instance of Multiplier with a factor of 2\ndouble = Multiplier(2)\n\n# Call the instance as if it were a function\nresult1 = double(5)  # This will return 10\nresult2 = double(10)  # This will return 20\n\nprint(result1)  # Output: 10\nprint(result2)  # Output: 20\n</code></pre> <p>Breakdown of the Example</p> <p>Defining the Class:</p> <p>Multiplier: This class has an init method that initializes an instance variable factor, which is used to multiply the input value when the object is called.</p> <p>Implementing call:</p> <p>The call method is defined, which takes a parameter number. When an instance of Multiplier is called with a number, it returns the product of that number and the factor.</p> <p>Creating an Instance:</p> <p>An instance of Multiplier is created with a factor of 2, which is assigned to the variable double.</p> <p>Using the Callable Instance:</p> <p>The instance double is called with different numbers (5 and 10), which internally invokes the call method. The results are 10 and 20, respectively.</p> <p>Advantages of Using Callable Objects</p> <ul> <li>Encapsulation: You can encapsulate related behavior and state within a single object.</li> <li>Flexibility: Callable objects can be modified easily by changing instance variables or methods without changing the external interface.</li> <li>Readability: Using callable objects can improve code readability by providing a clear and concise way to represent actions or transformations.</li> </ul> <p>Conclusion</p> <p>Callable objects in Python provide a powerful way to create function-like behavior within classes, enabling a blend of object-oriented design with functional programming styles. This flexibility can be particularly useful in various programming scenarios, such as callbacks, event handling, or creating reusable components.</p>"},{"location":"Python/Object%20Oriented%20Programming/classes/#82-repr-and-str","title":"8.2 repr and str","text":"<p>The str and repr methods are special methods used to define how an object is  represented as a string. </p> <p>They serve different purposes and are used in different contexts.</p>"},{"location":"Python/Object%20Oriented%20Programming/classes/#821-str","title":"8.2.1 str","text":"<p>Purpose: The str method is meant to provide a user-friendly string representation of an object. </p> <p>This representation is typically more readable and is designed for end-users. </p> <p>When you print an object or use str(object), Python calls the str method.</p> <p>Use Case: </p> <p>Use str when you want to create a string representation that is easy for humans to read and understand.</p> <p>Example:</p> <pre><code>class Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def __str__(self):\n        return f\"{self.name} is {self.age} years old.\"\n\n# Usage\np = Person(\"Alice\", 30)\nprint(p)  # Output: Alice is 30 years old.\n</code></pre>"},{"location":"Python/Object%20Oriented%20Programming/classes/#822-repr","title":"8.2.2  repr","text":"<p>Purpose: The repr method is intended to provide an official string representation of an object that can be used to recreate the object using eval() (if possible). The output of repr should be unambiguous and ideally could be used for debugging.</p> <p>Use Case: Use repr when you want to provide a representation that is more formal and could be useful for developers or debugging. It's aimed at developers rather than end-users.</p> <p>Example:</p> <pre><code>class Person:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def __repr__(self):\n        return f\"Person(name={self.name!r}, age={self.age})\"\n\n# Usage\np = Person(\"Alice\", 30)\nprint(repr(p))  # Output: Person(name='Alice', age=30)\n</code></pre>"},{"location":"Python/Object%20Oriented%20Programming/classes/#823-differences-between-__str__-and-__repr__","title":"8.2.3 Differences between <code>__str__</code> and <code>__repr__</code>","text":"Feature <code>__str__</code> <code>__repr__</code> Purpose Readable, user-friendly string Official string representation Context Used by <code>print()</code> and <code>str()</code> Used by <code>repr()</code> and in the shell Audience End-users Developers Return Value More informal and concise More formal and detailed"},{"location":"Python/Object%20Oriented%20Programming/classes/#824-why-use-both","title":"8.2.4 Why use both?","text":"<ul> <li>Clarity: By providing both methods, you can give different representations for different contexts. This helps make the object more usable and understandable for both end-users and developers.</li> <li>Flexibility: Users can print an object for human-readable output, while developers can use repr() for debugging and logging purposes, giving a clearer understanding of the object's state.</li> </ul>"},{"location":"Python/Object%20Oriented%20Programming/classes/#825-conclusion","title":"8.2.5 Conclusion","text":"<p>In summary, the str and repr methods allow you to define how objects of your class are represented as strings. Using both methods appropriately can enhance the usability and maintainability of your code, making it easier for both users and developers to work with your objects.</p>"},{"location":"Python/Object%20Oriented%20Programming/classes/#9-using-default-parameters-as-an-alternative-to-method-overloading","title":"9 Using Default Parameters as an Alternative to Method Overloading","text":"<ul> <li>Method overloading allows multiple methods with the same name but different signatures.</li> <li>Python does not natively support method overloading. Instead, we can use default parameters. <pre><code>class Human:\n    def sayHello(self, name=None):\n        \"\"\"Greets the person. If a name is provided, it greets that person; otherwise, it greets generically.\"\"\"\n        if name is not None:\n            print('Hello ' + name)\n        else:\n            print('Hello!')\n\n\n#Create an instance of the Human class\nobj = Human()\n\n #Call the method without parameters; it will execute the else part\nobj.sayHello()  # Output: Hello!\n\n# Call the method with a parameter; it will execute the if part\nobj.sayHello('Rahul')  # Output: Hello Rahul!\n</code></pre></li> </ul>"},{"location":"Python/Object%20Oriented%20Programming/classes/#10-inheritance-and-polymorphism-in-python","title":"10 Inheritance and Polymorphism in Python","text":"<p>Inheritance and polymorphism are fundamental concepts in Object-Oriented Programming (OOP)  that are crucial for writing efficient and reusable code. </p> <p>Understanding these concepts will significantly enhance your programming skills.</p>"},{"location":"Python/Object%20Oriented%20Programming/classes/#101-inheritance","title":"10.1 Inheritance","text":"<p>Inheritance is one of the primary advantages of OOP, allowing programmers to create a base class and extend  it into more specialized subclasses. </p> <p>This mechanism promotes code reusability and organization, reducing the need to rewrite code from scratch.</p> <p>In object-oriented terminology, when class X extends class Y, Y is referred to as the superclass,  parent class, or base class, while X is known as the subclass, child class, or derived class. </p> <p>One important point to note is that only non-private attributes and methods from the base class are  accessible by the child class. Private attributes and methods, defined with a single underscore _ or a  double underscore __, are not accessible to subclasses.</p> <p>Syntax for Creating a Derived Class</p> <p><pre><code>class BaseClass:\n    # Body of base class\n    pass\n\nclass DerivedClass(BaseClass):\n    # Body of derived class\n    pass\n</code></pre> Here's a simple example to illustrate inheritance in Python:</p> <p><pre><code># Base class\nclass Animal:\n    def __init__(self, name):\n        self.name = name\n\n    def speak(self):\n        raise NotImplementedError(\"Subclass must implement abstract method\")\n\n# Derived class\nclass Dog(Animal):\n    def speak(self):\n        return f\"{self.name} says Woof!\"\n\n# Another derived class\nclass Cat(Animal):\n    def speak(self):\n        return f\"{self.name} says Meow!\"\n\n# Creating instances of derived classes\ndog = Dog(\"Buddy\")\ncat = Cat(\"Whiskers\")\n\n# Calling the speak method\nprint(dog.speak())  # Output: Buddy says Woof!\nprint(cat.speak())  # Output: Whiskers says Meow!\n</code></pre> Explanation of the Example</p> <ul> <li>Base Class (Animal): This class defines a constructor that initializes the name attribute and an abstract method speak() that derived classes must implement.</li> <li>Derived Classes (Dog and Cat): These classes inherit from Animal and provide their specific implementations of the speak() method.</li> <li>Instantiation: We create instances of Dog and Cat, and when we call the speak() method on each object, we see that each class has its own behavior, demonstrating polymorphism. This allows different objects to be treated uniformly while still retaining their unique behaviors.</li> </ul> <p>Conclusion</p> <p>Inheritance is a powerful concept in Python that enables code reuse and better organization. </p> <p>By using inheritance, you can build more specialized classes based on general ones,  making your code more modular and easier to maintain. </p> <p>Understanding inheritance alongside polymorphism will help you harness the full potential of object-oriented programming in Python.</p>"},{"location":"Python/Object%20Oriented%20Programming/classes/#102-polymorphism-in-python-understanding-many-shapes","title":"10.2 Polymorphism in Python: Understanding \u201cMany Shapes\u201d","text":"<p>Polymorphism is a key feature of Object-Oriented Programming (OOP) in Python that allows methods to  operate on objects of different types through a common interface.  It provides flexibility and loose coupling, making code easier to extend and maintain.</p>"},{"location":"Python/Object%20Oriented%20Programming/classes/#1021-what-is-polymorphism","title":"10.2.1 What is Polymorphism?","text":"<p>Polymorphism allows functions to use objects of different classes without needing to know their specific types. </p> <p>This means that if two or more classes share methods with the same name, these methods can be  invoked regardless of the object\u2019s class.</p> <p>Example of Polymorphism</p> <p>Consider a scenario where we have a base class Animal and two subclasses Dog and Cat.</p> <p>Each subclass implements a common method called show_affection():</p> <p><pre><code>class Animal:\n    def show_affection(self):\n        raise NotImplementedError(\"Subclass must implement abstract method\")\n\nclass Dog(Animal):\n    def show_affection(self):\n        return \"The dog wags its tail.\"\n\nclass Cat(Animal):\n    def show_affection(self):\n        return \"The cat purrs.\"\n\n# Function to demonstrate polymorphism\ndef display_affection(animal):\n    print(animal.show_affection())\n\n# Creating instances\ndog = Dog()\ncat = Cat()\n\n# Demonstrating polymorphism\ndisplay_affection(dog)  # Output: The dog wags its tail.\ndisplay_affection(cat)  # Output: The cat purrs.\n</code></pre> In the above example, the function display_affection() can accept any object of type Animal, regardless of whether it\u2019s a Dog or a Cat. This is the essence of polymorphism. Overriding Methods</p> <p>In Python, subclasses can override methods from their parent class. </p> <p>When a method in a subclass has the same name as a method in the parent class,  the subclass's method is called instead.</p> <p>Example of Overriding</p> <p>Here's an example that illustrates method overriding: <pre><code>class Thought:\n    def __init__(self):\n        pass\n\n    def message(self):\n        print(\"Thoughts always come and go.\")\n\nclass Advice(Thought):\n    def __init__(self):\n        super().__init__()\n\n    def message(self):\n        print(\"Warning: Risk is always involved when dealing with the market!\")\n\n# Using the classes\nthought = Thought()\nadvice = Advice()\n\nthought.message()  # Output: Thoughts always come and go.\nadvice.message()   # Output: Warning: Risk is always involved when dealing with the market!\n</code></pre> Inheriting Constructors</p> <p>In Python, if a subclass does not define its own constructor (init method),  it will inherit the constructor of its parent class. </p> <p>However, if the subclass does define its constructor, it can still call the parent class's constructor  using the super() function. </p> <p>This is crucial for initializing the parent class's attributes.</p> <p>Example of Inheriting Constructors</p> <p>Here's an example of inheriting constructors: <pre><code>class Animal:\n    def __init__(self, name):\n        self.name = name\n\nclass Dog(Animal):\n    def __init__(self, name, breed):\n        super().__init__(name)  # Call the constructor of Animal\n        self.breed = breed\n\n# Creating an instance of Dog\nmy_dog = Dog(\"Buddy\", \"Golden Retriever\")\nprint(f\"{my_dog.name} is a {my_dog.breed}.\")  # Output: Buddy is a Golden Retriever.\n</code></pre></p>"},{"location":"Python/Object%20Oriented%20Programming/classes/#conclusion","title":"Conclusion","text":"<p>Polymorphism allows objects of different classes to be treated as objects of a common superclass,  enhancing flexibility in your code.</p> <p>Method overriding enables subclasses to provide specific implementations for methods defined in their parent classes.</p> <p>The super() function is essential for calling methods in the parent class,  including constructors, ensuring proper initialization of objects.</p> <p>By leveraging polymorphism, overriding, and inheritance, you can write cleaner,  more modular code that is easier to maintain and extend.</p>"},{"location":"Python/Object%20Oriented%20Programming/classes/#11-multiple-inheritance-in-python","title":"11 Multiple Inheritance in Python","text":"<p>Multiple Inheritance allows a class to inherit from more than one base class. </p> <p>This is useful in scenarios where a class should exhibit behaviors from multiple sources. Syntax</p> <p>To define a class with multiple inheritance, list the parent classes in parentheses, separated by commas.</p> <p>Example of Multiple Inheritance</p> <p>Let's consider a simple scenario where we have two base classes, Person and Employee,  and a derived class Manager that inherits from both:</p> <p><pre><code>class Person:\n    def __init__(self, name):\n        self.name = name\n\n    def display_name(self):\n        print(f\"Name: {self.name}\")\n\nclass Employee:\n    def __init__(self, employee_id):\n        self.employee_id = employee_id\n\n    def display_id(self):\n        print(f\"Employee ID: {self.employee_id}\")\n\n# Manager class inherits from both Person and Employee\nclass Manager(Person, Employee):\n    def __init__(self, name, employee_id, department):\n        # Initialize the parent classes\n        Person.__init__(self, name)\n        Employee.__init__(self, employee_id)\n        self.department = department\n\n    def display_info(self):\n        self.display_name()\n        self.display_id()\n        print(f\"Department: {self.department}\")\n\n# Creating an instance of Manager\nmanager = Manager(\"Alice\", \"E123\", \"Sales\")\n\n# Displaying information\nmanager.display_info()\n</code></pre> output <pre><code>Name: Alice\nEmployee ID: E123\nDepartment: Sales\n</code></pre></p>"},{"location":"Python/Object%20Oriented%20Programming/classes/#explanation","title":"Explanation","text":""},{"location":"Python/Object%20Oriented%20Programming/classes/#base-classes","title":"Base Classes:","text":"<p>Person has an attribute name and a method display_name().</p> <p>Employee has an attribute employee_id and a method display_id().</p>"},{"location":"Python/Object%20Oriented%20Programming/classes/#derived-class","title":"Derived Class:","text":"<p>Manager inherits from both Person and Employee.</p> <p>Its constructor initializes both base classes using their respective init methods.</p> <p>The display_info() method calls methods from both parent classes, demonstrating how the  derived class can access inherited attributes and methods.</p> <p>Method Resolution Order (MRO)</p> <p>Python uses the C3 linearization algorithm to determine the order in which classes are looked up when  searching for a method. </p> <p>You can check the MRO of a class using the mro attribute or the mro() method: <pre><code>print(Manager.__mro__)\n# Output: (&lt;class '__main__.Manager'&gt;, &lt;class '__main__.Person'&gt;, &lt;class '__main__.Employee'&gt;, &lt;class 'object'&gt;)\n</code></pre> Conclusion Flexibility: Multiple inheritance allows a class to combine behaviors from multiple sources,  increasing flexibility in your design.</p> <p>Complexity: Be cautious when using multiple inheritance, as it can lead to complexities,  especially with method name clashes and the MRO. </p> <p>Properly understanding the order of resolution is crucial to avoid unexpected behavior.</p>"},{"location":"Python/Object%20Oriented%20Programming/classes/#12-decorators-static-methods-and-class-methods-in-python","title":"12 Decorators, Static Methods, and Class Methods in Python","text":"<p>In Python, functions (or methods) are typically created using the def statement. </p> <p>While methods behave similarly to functions, they have an important distinction: the first argument of a  method is always the instance object. Methods can be classified based on their behavior:</p> <ul> <li>Simple Function: Defined outside of a class and can access class attributes via an instance argument.</li> <li>Instance Method: Defined within a class and takes self as the first parameter.</li> <li>Class Method: Uses the @classmethod decorator and takes cls as the first parameter, allowing access to class attributes.</li> <li>Static Method: Uses the @staticmethod decorator and does not take self or cls as a parameter, making it independent of the class and instance state.</li> </ul> <p>Instance Method</p> <p>An instance method is the most common type of method. It takes self as its first parameter,  allowing it to access instance attributes and methods.</p> <p>Example <pre><code>class Dog:\n    def __init__(self, name):\n        self.name = name\n\n    def bark(self):\n        return f\"{self.name} says Woof!\"\n\n# Creating an instance of Dog\ndog = Dog(\"Buddy\")\nprint(dog.bark())  # Output: Buddy says Woof!\n</code></pre> Class Method</p> <p>A class method is defined using the @classmethod decorator. </p> <p>It takes cls as its first parameter, allowing access to class attributes and methods. </p> <p>Class methods are often used to create factory methods that return instances of the class.</p> <p>Example <pre><code>class Dog:\n    species = \"Canis familiaris\"\n\n    def __init__(self, name):\n        self.name = name\n\n    @classmethod\n    def create_with_species(cls, name):\n        return cls(name)  # Returns an instance of Dog with a name\n\n# Creating an instance of Dog using the class method\ndog = Dog.create_with_species(\"Max\")\nprint(dog.name)  # Output: Max\nprint(Dog.species)  # Output: Canis familiaris\n</code></pre> Static Method</p> <p>A static method is defined using the @staticmethod decorator. </p> <p>It does not take self or cls as a parameter, meaning it cannot access instance or class attributes. </p> <p>Static methods are often used for utility functions that perform a task without needing to modify  the class or instance state.</p> <p>Example <pre><code>class Math:\n    @staticmethod\n    def add(a, b):\n        return a + b\n\n# Calling the static method\nresult = Math.add(5, 3)\nprint(result)  # Output: 8\n</code></pre> When to Use Each Type</p> <ul> <li>Instance Methods: Use when you need to access or modify instance-specific data.</li> <li>Class Methods: Use for factory methods or when you need to access class-level data. They are often used to create alternate constructors.</li> <li>Static Methods: Use for utility functions that do not require access to instance or class data.</li> </ul> <p>Summary</p> <ul> <li>Instance Method: Can modify object state and access instance attributes using self.</li> <li>Class Method: Can modify class state and access class attributes using cls. Ideal for factory methods.</li> <li>Static Method: Cannot modify object or class state. Suitable for utility functions that don't depend on class or instance context.</li> </ul>"},{"location":"Python/Object%20Oriented%20Programming/datastructures/","title":"Data Structures in OOP Python","text":""},{"location":"Python/Object%20Oriented%20Programming/datastructures/#1-lists","title":"1. Lists","text":"<ul> <li>Description: A list is an ordered, mutable (modifiable) collection of items. Lists can contain elements of different types.</li> <li>Creation:      <pre><code>my_list = [1, 2, 3, 'four', 5.0]\n</code></pre></li> <li>Adding Items:<ul> <li>Append: Adds an item to the end of the list.     <pre><code>my_list.append(6)\n</code></pre></li> <li>Insert: Inserts an item at a specified index.     <pre><code>my_list.insert(1, 'two')  # Inserts 'two' at index 1\n</code></pre></li> <li>Insert at beginning of list: ie (index 0).     <pre><code>my_list.insert(0, 'two')  # Inserts 'two' at index 0\n</code></pre></li> </ul> </li> <li>Removing Items:<ul> <li>Remove: Removes the first occurrence of a value.     <pre><code>my_list.remove('four')\n</code></pre></li> <li>Pop: Removes an item at a specified index (or the last item if no index is specified).     <pre><code>last_item = my_list.pop()  # Removes the last item\n</code></pre></li> </ul> </li> </ul>"},{"location":"Python/Object%20Oriented%20Programming/datastructures/#2-empty-objects","title":"2. Empty Objects","text":"<ul> <li>Description: An empty object can be created using a class. It serves as a container for attributes and methods.</li> <li>Creation:     <pre><code>class MyClass:\n    pass\n\nempty_object = MyClass()\n</code></pre></li> <li>Adding Attributes:     <pre><code>empty_object.name = \"John Doe\"\nempty_object.age = 30\n</code></pre></li> <li>Accessing Attributes:     <pre><code>print(empty_object.name)  # Output: John Doe\n</code></pre></li> </ul>"},{"location":"Python/Object%20Oriented%20Programming/datastructures/#3-tuples","title":"3. Tuples","text":"<p>Description: A tuple is an ordered, immutable (non-modifiable) collection of items.  - Once created, the items cannot be changed.</p> <ul> <li>You cannot add elements to a tuple.</li> <li>You cannot append or extend a method.</li> <li>You cannot remove elements from a tuple.</li> <li>Tuples have no remove or pop method.</li> <li> <p>Count and index are the methods available in a tuple.</p> </li> <li> <p>Creation:     <pre><code>my_tuple = (1, 2, 3, 'four')\n</code></pre></p> </li> <li>Accessing Items:     <pre><code>first_item = my_tuple[0]  # Output: 1\n</code></pre></li> <li>Slicing: You can access a range of items.     <pre><code>sliced = my_tuple[1:3]  # Output: (2, 3)\n</code></pre></li> </ul>"},{"location":"Python/Object%20Oriented%20Programming/datastructures/#4-dictionaries","title":"4. Dictionaries","text":"<ul> <li>Description: A dictionary is an unordered, mutable collection of key-value pairs. Keys must be unique.</li> <li>Creation:     <pre><code>my_dict = {'name': 'Alice', 'age': 30, 'city': 'New York'}\n</code></pre></li> <li>Adding Items:     <pre><code>my_dict['job'] = 'Engineer'  # Adds a new key-value pair\n</code></pre></li> <li>Removing Items:<ul> <li>Del: Deletes a key-value pair.     <pre><code>del my_dict['age']  # Removes the key 'age'\n</code></pre></li> <li>Pop: Removes a key and returns its value.     <pre><code>city = my_dict.pop('city')  # Removes 'city' and returns its value\n</code></pre></li> <li>Clear: Removes all keys and values.     <pre><code>my_dict.clear()  # Clears the list\n</code></pre></li> </ul> </li> </ul> <p>Take note : </p> <ul> <li>Empty dictionary: {} is always interpreted as an empty dictionary.</li> <li>Empty set: To create an empty set, you must use set().</li> </ul> <p>Key Points: - Dictionaries hold key-value pairs, while sets only contain unique values. - {} by default represents an empty dictionary, not a set. - To create a non-empty set, you can use curly braces with values, but for an empty set, you must use set(). <pre><code># This is an empty dictionary\nmy_dict = {}\nprint(type(my_dict))  # Output: &lt;class 'dict'&gt;\n\n# This is an empty set\nmy_set = set()\nprint(type(my_set))  # Output: &lt;class 'set'&gt;\n\n# Non-empty set using curly braces\nnon_empty_set = {1, 2, 3}\nprint(type(non_empty_set))  # Output: &lt;class 'set'&gt;\n\n# Non-empty dictionary with curly braces\nnon_empty_dict = {'a': 1, 'b': 2}\nprint(type(non_empty_dict))  # Output: &lt;class 'dict'&gt;\n</code></pre> Why the Difference?</p> <p>Dictionaries need a specific syntax to represent key-value pairs ({key: value}). Sets use curly braces too, but only contain values ({value1, value2}), so Python reserved {} for empty dictionaries to avoid confusion.</p>"},{"location":"Python/Object%20Oriented%20Programming/datastructures/#5-sets","title":"5. Sets","text":"<ul> <li>Description: A set is an unordered collection of unique items. It is mutable but does not allow duplicate values.</li> <li>Creation:     <pre><code>my_set = {1, 2, 3, 4}\n</code></pre></li> <li>Adding Items:     <pre><code>my_set.add(5)  # Adds 5 to the set\n</code></pre></li> <li>Removing Items:<ul> <li>Remove: Removes a specified item. Raises an error if the item is not found.     <pre><code>my_set.remove(2)\n</code></pre></li> <li>Discard: Removes a specified item. Does not raise an error if the item is not found.     <pre><code>my_set.discard(3)\n</code></pre></li> </ul> </li> <li>Operations: Sets support mathematical operations like union, intersection, and difference.     <pre><code>another_set = {3, 4, 5, 6}\nunion_set = my_set | another_set  # Union\nintersection_set = my_set &amp; another_set  # Intersection\n</code></pre></li> </ul>"},{"location":"Python/Object%20Oriented%20Programming/datastructures/#summary-table","title":"Summary Table","text":"Data Structure Mutability Ordered Example Adding Items Removing Items List Mutable Yes <code>my_list = [1, 2, 3]</code> <code>my_list.append(4)</code> <code>my_list.remove(2)</code> Empty Object Mutable Yes <code>empty_object = MyClass()</code> <code>empty_object.attr = value</code> N/A (can delete attributes) Tuple Immutable Yes <code>my_tuple = (1, 2, 3)</code> N/A N/A Dictionary Mutable No <code>my_dict = {'key': 'value'}</code> <code>my_dict['new_key'] = 'new_value'</code> <code>del my_dict['key']</code> Set Mutable No <code>my_set = {1, 2, 3}</code> <code>my_set.add(4)</code> <code>my_set.remove(2)</code>"},{"location":"Python/Object%20Oriented%20Programming/datastructures/#conclusion","title":"Conclusion","text":"<p>These data structures are fundamental to Python and are used extensively in OOP. Each has its own use cases and advantages, allowing for flexible and efficient data management in your programs. Understanding these data structures will help you design better algorithms and data flows in your applications.</p>"},{"location":"Python/Object%20Oriented%20Programming/modulesvsclasses/","title":"Modules vs Classes","text":"<p>A module is a file that contains Python code (functions, variables, classes)  that can be imported and reused across different programs.</p> <p>Modules are used to organize related functions, variables, and classes into a single namespace,  making your code more modular and reusable.</p> <p>Classes, on the other hand, are used to create objects.  Classes allow you to define the structure (attributes) and behavior (methods) of objects. </p> <p>While a module organizes code at the file level, a class organizes it at a more granular,  object-oriented level.</p> <p>Dictionaries store key-value pairs, whereas modules contain Python objects  (functions, classes, etc.) that can be accessed using dot notation.</p>"},{"location":"Python/Object%20Oriented%20Programming/modulesvsclasses/#modules-are-like-dictionaries","title":"Modules are like \u201cDictionaries\u201d","text":"<p>When working on Modules, note the following points:</p> <ul> <li>A Python module is a package to encapsulate reusable code.</li> <li>Modules reside in a folder with a init.py file on it.</li> <li>Modules contain functions and classes.</li> <li>Modules are imported using the import keyword.</li> </ul> <p>Recall that a dictionary is a key-value pair. That means if you have a dictionary with a key EmployeID and you want to retrieve it, then you will have to use the following lines of code: <pre><code># employee.py\nemployee_name = \"John\"\nemployee_id = 12345\n\ndef get_employee_id():\n    return employee_id\n</code></pre> You can import this module and use it like this:</p> <p><pre><code>import employee\n\nprint(employee.employee_name)  # Access a variable from the module\nprint(employee.get_employee_id())  # Call a function from the module\n</code></pre> an equivalent class for the employee module would look like this:</p> <pre><code>class Employee:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def get_employee_id(self):\n        return \"Employee ID is: 12345\"\n\n# Instantiate an Employee object\nemployee_obj = Employee(\"John\", 30)\n\n# Access the properties and methods\nprint(employee_obj.name)  # Access the name attribute\nprint(employee_obj.get_employee_id())  # Call the method\n</code></pre> <p>Key Differences between Modules and Classes: Scope:</p> <ul> <li>Modules: Contain functions, variables, and classes. They are global and reusable throughout the entire program.</li> <li>Classes: Define objects with attributes and methods. They are meant for object-oriented programming and encapsulation.</li> </ul> <p>Reusability:</p> <ul> <li>Modules: Reused by importing them into different files. You can use their functions and variables directly.</li> <li>Classes: Need to be instantiated into objects. You can reuse the class by creating multiple instances (objects).</li> </ul>"},{"location":"Python/Object%20Oriented%20Programming/modulesvsclasses/#classes-are-like-modules","title":"Classes are like Modules","text":"<p>Module is a specialized dictionary that can store Python code so you can get to it with the \u2018.\u2019 Operator. A class is a way to take a grouping of functions and data and place them inside a container so you can access them with the \u2018.\u2018operator.</p> <p>Note: Classes are preferred over modules because you can reuse them as they are and without much interference. While with modules, you have only one with the entire program.</p> <p>A class is like a blueprint for creating objects. When you create (instantiate) an object from a class, you get an independent instance of that class, with its own data.</p> <pre><code>class Employee:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n# Creating two independent objects (instances) from the class\nemployee1 = Employee(\"John\", 30)\nemployee2 = Employee(\"Jane\", 25)\n\n# Each object has its own data\nprint(employee1.name)  # Output: John\nprint(employee2.name)  # Output: Jane\n</code></pre> <p>Variable Scope:</p> <p>Modules have global scope once imported, whereas classes have instance-specific attributes  (defined with self), making them more suited for encapsulation.</p> <p>Final Comments and Recommendations:</p> <ul> <li>Modules: Use them when you need to group related functions, variables, or classes in a single file for reuse across your project.</li> <li>Classes: Use them for object-oriented design when you need to encapsulate data and functionality that should be grouped together in objects.</li> </ul> <p>Extended Example with Both Modules and Classes:</p> <p><pre><code># employee.py (Module)\nclass Employee:\n    def __init__(self, name, age):\n        self.name = name\n        self.age = age\n\n    def get_employee_info(self):\n        return f\"{self.name}, {self.age}\"\n\n# Utility function outside the class\ndef greet_employee(employee):\n    return f\"Welcome {employee.name}!\"\n</code></pre> Usage:</p> <pre><code># main.py\nimport employee  # Importing the module\n\n# Create an instance of Employee class\njohn = employee.Employee(\"John\", 30)\n\n# Access class method\nprint(john.get_employee_info())  # Output: John, 30\n\n# Use module-level function\nprint(employee.greet_employee(john))  # Output: Welcome John!\n</code></pre> <p>This demonstrates how a module can contain both class definitions and standalone functions.</p>"},{"location":"mkdocs/adminitions/","title":"Adminitions","text":"<p>Example of an admonition/callout with a title:</p> <p>Title of the callout</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Collapsible callout:</p> Collapsible callout <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Admonition without title</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> Note <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p>"},{"location":"mkdocs/buttons/","title":"Buttons","text":""},{"location":"mkdocs/buttons/#usage","title":"Usage","text":"<p>Adding buttons</p> <p>In order to render a link as a button, suffix it with curly braces and add the .md-button class selector to it. The button will receive the selected primary color and accent color if active. Button</p> <p>Subscribe to our newsletter</p> <p>Adding primary buttons</p> <p>If you want to display a filled, primary button (like on the landing page of Material for MkDocs), add both, the .md-button and .md-button--primary CSS class selectors. Button, primary</p> <p>Subscribe to our newsletter</p> <p>Adding icon buttons</p> <p>Of course, icons can be added to all types of buttons by using the icon syntax together with any valid icon shortcode, which can be easily found with a few keystrokes through our icon search. Button with icon</p> <p>Send </p>"},{"location":"mkdocs/code-examples/","title":"Code examples","text":"<p>An example of a codeblock for Python:</p> add_numbers.py<pre><code># Function to add two numbers\ndef add_two_numbers(num1, num2):\n    return num1 + num2\n\n# Example usage\nresult = add_two_numbers(5, 3)\nprint('The sum is:', result)\n</code></pre> <p>Example codeblock for JavaScript with lines highlighted:</p> concatenate_strings.js<pre><code>// Function to concatenate two strings\nfunction concatenateStrings(str1, str2) {\n  return str1 + str2;\n}\n\n// Example usage\nconst result = concatenateStrings(\"Hello, \", \"World!\");\nconsole.log(\"The concatenated string is:\", result);\n</code></pre>"},{"location":"mkdocs/diagram-examples/","title":"Diagram Examples","text":""},{"location":"mkdocs/diagram-examples/#flowcharts","title":"Flowcharts","text":"<pre><code>graph LR\n  A[Start] --&gt; B{Failure?};\n  B --&gt;|Yes| C[Investigate...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Success!];</code></pre>"},{"location":"mkdocs/diagram-examples/#sequence-diagrams","title":"Sequence Diagrams","text":"<pre><code>sequenceDiagram\n  autonumber\n  Server-&gt;&gt;Terminal: Send request\n  loop Health\n      Terminal-&gt;&gt;Terminal: Check for health\n  end\n  Note right of Terminal: System online\n  Terminal--&gt;&gt;Server: Everything is OK\n  Terminal-&gt;&gt;Database: Request customer data\n  Database--&gt;&gt;Terminal: Customer data</code></pre>"},{"location":"mkdocs/grid/","title":"Grids","text":"<ul> <li> HTML for content and structure</li> <li> JavaScript for interactivity</li> <li> CSS for text running out of boxes</li> <li> Internet Explorer ... huh?</li> </ul> <ul> <li> <p> Set up in 5 minutes</p> <p>Install <code>mkdocs-material</code> with <code>pip</code> and get up and running in minutes</p> <p> Getting started</p> </li> <li> <p> It's just Markdown</p> <p>Focus on your content and generate a responsive and searchable static site</p> <p> Reference</p> </li> <li> <p> Made to measure</p> <p>Change the colors, fonts, language, icons, logo and more with a few lines</p> <p> Customization</p> </li> <li> <p> Open Source, MIT</p> <p>Material for MkDocs is licensed under MIT and available on [GitHub]</p> <p> License</p> </li> </ul> <p> HTML for content and structure</p> <p> JavaScript for interactivity</p> <p> CSS for text running out of boxes</p> <p> Internet Explorer ... huh?</p>"},{"location":"mkdocs/setup/","title":"Material MkDocs","text":""},{"location":"mkdocs/setup/#initial-setup-steps","title":"Initial setup steps","text":"<ul> <li>Create folder for site</li> <li>in terminal create and activate venv</li> <li>pip install mkdocs-material</li> <li>open folder in editor and in editr terminal activate venv</li> <li>create new mkdocs <code>mkdocs new .</code></li> <li>if only site on port 8000 <code>mkdocs serve</code></li> <li>if 8000 not available `mkdocs serve -a localhost:9999</li> <li>`</li> </ul>"},{"location":"mkdocs/tab-examples/","title":"Tab examples","text":""},{"location":"mkdocs/tab-examples/#content-tabs","title":"Content Tabs","text":"<p>This is some examples of content tabs.</p>"},{"location":"mkdocs/tab-examples/#generic-content","title":"Generic Content","text":"Plain textUnordered listOrdered list <p>This is some plain text</p> <ul> <li>First item</li> <li>Second item</li> <li>Third item</li> </ul> <ol> <li>First item</li> <li>Second item</li> <li>Third item</li> </ol>"},{"location":"mkdocs/tab-examples/#code-blocks-in-content-tabs","title":"Code Blocks in Content Tabs","text":"PythonJavaScript <pre><code>def main():\n    print(\"Hello world!\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <pre><code>function main() {\n    console.log(\"Hello world!\");\n}\n\nmain();\n</code></pre>"}]}